{0:top pacomb}

+ {{:#overview} What is Pacomb?}
+ {{:#ppx} OCaml syntax extension}
+ {{:#limitations} Limitation}
+ {!Pacomb.Grammar} The main module to build grammars
+ {!Pacomb.Comb} Our combinator library, contains the function to call the parser
+ {!Pacomb.Lex} lexing and blanks
+ {!Pacomb.Pos} positions in file
+ {!Pacomb.Input} build input buffer from string, channel, ...
+ {!Pacomb.Charset} an efficient representation of character sets

{1:overview Overview}

PaComb implements a representation of grammars with semantic actions (values
returned as a result of parsing). Parsing is performed by compiling grammars
defined with the [Grammar] module (or indirectly though a PPX extension) to
the combinators of the [Comb] module. The library offers {e scanner less}
parsing, but the [Lex] module provide a notion of {e terminals} and {e blanks}
that give a simple way to write grammars in two phases, as usual.

The main advantage of PaComb and similar solutions, contrary to ocamlyacc, is
that grammars (compiled or not) are {e first class values}. This allows using
the full power of OCaml for manipulating grammars. For example, this is very
useful when working with syntax extension mechanisms.

Importantly, {e performances} of PaComb are very good: it is only two to
three times slower than grammars generated by ocamlyacc.

{1:ppx PPX syntax extension}

Defining languages using the [Grammar] module directly is cumbersome. For that
reason, PaComb provides a BNF-like PPX syntax extension (enabled using the
[-ppx pacombPpx] compilation flag). An example with arithmetic expressions is
given below.
{[
[%%parser
   type p = Atom | Prod | Sum
   let rec expr p =
     Atom < Prod < Sum
     ; (p=Atom) (x::FLOAT)                        => x
     ; (p=Atom) '(' (e::expr Sum) ')'             => e
     ; (p=Prod) (x::expr Prod) '*' (y::expr Atom) => x *. y
     ; (p=Prod) (x::expr Prod) '/' (y::expr Atom) => x /. y
     ; (p=Sum ) (x::expr Sum ) '+' (y::expr Prod) => x +. y
     ; (p=Sum ) (x::expr Sum ) '-' (y::expr Prod) => x -. y
]]}

The extension [[%%parser ...]] extends ocaml expressions with grammars of
type ['a Grammar.t] and modifies the behaviour of let-bindings especially
recursive ones to use [declare_grammar], [set_grammar] and
[grammar_family]. Recall that due to the limitation of
ppx, we use a sub syntax of OCaml expressions for grammars. It is therefore
not a good idea to use "=>" as an infix inside [[%parser ...]].


We give below the BNF grammar for the extension, together with a sketch of
its semantics.
{[
grammar ::= rule                                                   itself
       | grammar ; rule                                       Grammar.alt
rule ::= qitems => expr                            A rule with its action
       | expr < ... < expr                       priority order see below
qitems ::= ()                                               Grammar.empty
       | non_empty_qitems                                          itself
non_empty_qitems ::= qitem                                         itself
       | non_empty_qitems qitems                              Grammar.seq
qitem ::= item | (pat :: item)          give a name if used in the action
item ::= '...'                                  Grammar.term(Lex.char ())
       | "..."                                Grammar.term(Lex.string ())
       | INT                                     Grammar.term(Lex.int ())
       | FLOAT                                 Grammar.term(Lex.float ())
       | RE(expr)      Grammar.term(Lex.regexp (Regexp.from_string expr))
       | expr                                                      itself
pat ::= lid
       | (pat : coretype)
       | pat = lid                               encoding of [pat as lid]
       | (pat, ..., pat)
       | M.pat
]}
[pat] correspond to an encoding of patterns in expressions. Beware that [_] is
invalid, use [__] instead.

In action code (expression right of [=>]), a [lid_lpos] or [lid_rpos] will
denote respectively the left and right position of the item named [lid].  If
the item is matched by a tuple and you want to use its positon you must use
[pat = lid] syntax to give a name to the whole item.

The grammar above allows for some nesting as in:
{[
[%%parser
 type p = Atom | Prod | Sum
 let rec
     expr p = Atom < Prod < Sum
            ; (p=Atom) (x::FLOAT)                        => x
            ; (p=Atom) '(' (e::expr Sum) ')'             => e
            ; (p=Prod) (x::expr Prod) => ( '*' (y::expr Atom) => x*.y
                                         ; '/' (y::expr Atom) => x/.y)
            ; (p=Sum ) (x::expr Sum ) => ('+' (y::expr Prod) => x+.y
                                         ; '-' (y::expr Prod) => x-.y)
]}

But when using this, beware that [x] is not available before the final action
code, it can not be used for selecting  grammar rule. [(p::prio) => (x::g p) => x]
will report [p] as unbounded.

Here are the meaning of let bindings for grammars through the ppx extension:
- non recursive let bindings correspond to just a name for the grammar.
- recursive let bindings correspond either to
  - [Grammar.declare_grammar + Grammar.set_grammar] (if no paramater)
  - [Grammar.grammar_familly + setting the grammar] if a parameter is given.

A rule [p_1 < p_2 < ... < p_n] will automatically add rules to
include the grammar parametrized by [p_i] in the grammar parametrized by
[p_(i+1)]. Recall that due to the type of [Grammar.grammar_family] can
only have one parameter.

Anything which does not correspond to this grammar will be unchanged
in the ocaml code (like the type definition in the example
above).  A mutually recursive definition can also mix the definition of
grammars (parametric of not) with the definition of normal ocaml values.
This means you could put the whole file between inside [%%parse ...].

{1:limitations Limitations}

Pacomb must eliminate left recursion in grammars in order to use combinators
that would loop otherwise. However, left recursion is not supported if it
traverses:

- A [Grammar.layout] contructor to change blanks (probably possible to solve this,
  but probably not woth it).

Grammars are not left factorised automatically: (A B) | (A C) may parse A twice and
this may result in very poor performance. Two solutions:
  - left factorise your grammar yourself,
  - Use Grammar.cache trading memory for speed.

The ppx extension is not too bad but still suffers from the fact that it uses
a sublanguage of OCaml to describe grammar. For instance [[%parser let g =
((_,x)::g) => x]] is not legal because [_] cannot be used in an Ocaml
expression. Though the following works: [[%parser let g = ((__,x)::g) => x]]
