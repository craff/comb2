{0:top pacomb}

+ {{:#overview} What is Pacomb?}
+ {{:#ppx} OCaml syntax extension}
+ {{:#limitations} Limitation}
+ {!Pacomb.Grammar} The main module to build grammars
+ {!Pacomb.Lex} lexing and {!Pacomb.Lex.give_up}
+ {!Pacomb.Blank} blanks and layout record
+ {!Pacomb.Pos} positions in file and handling of exceptions
+ {!Pacomb.Keyword} Some function to parse and reserve keywords
+ {!Pacomb.Word_list} An efficient extensible dictionnary to parse words
+ {!Pacomb.Regexp} Regexp implementation above {!Pacomb.Lex}
+ {!Pacomb.Input} build input buffer from string, channel, ...
+ {!Pacomb.Charset} an efficient representation of character sets

{1:overview Overview}

PaComb implements a representation of grammars with semantic actions (values
returned as a result of parsing). Parsing is performed by compiling grammars
defined with the {!Pacomb.Grammar} module (or indirectly though a PPX extension)
to combinators. The library offers {e scanner less} parsing, but the
{!Pacomb.Lex} module provide a notion of {e terminals} and the {!Pacomb.Blank}
module allows to define function ignoring spaces and comments. This gives a
simple way to write grammars in two phases, as usual.

The main advantage of PaComb and similar solutions, contrary to ocamlyacc, is
that grammars (compiled or not) are {e first class values}. This allows using
the full power of OCaml for manipulating grammars. For example, this is very
useful when working with syntax extension mechanisms.

Importantly, {e performances} of PaComb are very good: it is often less then two
times slower than grammars generated by ocamlyacc. However, using specific
Pacomb features like dependant sequences or cache will result in much slower
grammar ... than you can not always write with ocamlyacc anyway.

{1:ppx PPX syntax extension}

Defining languages using the {!Pacomb.Grammar} module directly is cumbersome.
For that reason, PaComb provides a BNF-like PPX syntax extension. An example
with arithmetic expressions is given below. It can be compiled with command
[ocamlfind ocamlopt -package pacomb,pacomb.ppx -o calc -linkpkg calc.ml] (if
it is written to a file [calc.ml]).
{[
   type p = Atom | Prod | Sum
   let%parser rec expr p =
     Atom < Prod < Sum
     ; (p=Atom) (x::FLOAT)                        => x
     ; (p=Atom) '(' (e::expr Sum) ')'             => e
     ; (p=Prod) (x::expr Prod) '*' (y::expr Atom) => x *. y
     ; (p=Prod) (x::expr Prod) '/' (y::expr Atom) => x /. y
     ; (p=Sum ) (x::expr Sum ) '+' (y::expr Prod) => x +. y
     ; (p=Sum ) (x::expr Sum ) '-' (y::expr Prod) => x -. y
]}

To use the above parser, you need to define a toplevel rule,
say which characteres to ignore and call the parser on a file or string. For
instance the following will work and handle parse error without exiting the program:
{[
(* The parsing calling expression, printing the result and the next prompt. *)
let%parser rec exprs =
    () => ()
  ; exprs (e::expr Sum) '\n' => Printf.printf "%f\n=> %!" e

(* blanks, i.e. characteres to be ignored *)
let blank = Blank.from_charset (Charset.singleton ' ')

let _ =
  try
    while true do
      let f () =
        Printf.printf "=> %!"; (* initial prompt *)
        Grammar.parse_channel exprs blank stdin
      in
      (* [Pos] module provides a function to handle exception with
         an optional argument to call for error (default is to exit with
         code 1 *)
      Pos.handle_exception ~error:(fun _ -> ()) f ()
    done
  with
    End_of_file -> ()

]}
This works using the extensions [[%%parser ...]] for structures and [[%parser
...]] for expression. These are also accessible by suffixing keywords with
[%parser] as in the above example. These ppx extensions extends ocaml
expressions with a syntax for grammars of type ['a Grammar.t] and modifies the
behaviour of let-bindings especially recursive ones to use [declare_grammar],
[set_grammar] and [grammar_family]. Recall that due to the limitation of ppx, we
use a sub-syntax of OCaml expressions for grammars. It is therefore not a good
idea to use "=>" as an infix inside [[%parser ...]].

We give below the BNF grammar for the extension, together with a sketch of
its semantics.
{[
grammar ::= rule                                                   itself
       | grammar ; rule                                       Grammar.alt
rule ::= qitems => expr                            A rule with its action
       | expr < ... < expr                       priority order see below
       | ERROR(m)                   report an error if parsing fails here
qitems ::= ()                                               Grammar.empty
       | non_empty_qitems                                          itself
       | cond non_empty_qitems                           conditional rule
cond ::= expr bool_op expr
       | not expr
non_empty_qitems ::= qitem                                         itself
       | non_empty_qitems qitems                              Grammar.seq
qitem ::= item                                                     itself
       | (epat :: item)                 give a name if used in the action
       | ((epat,epat) >: item)                     as above, but for dseq
item ::= '...'                                  Grammar.term(Lex.char ())
       | CHAR                                    Grammar.term(Lex.any ())
       | CHAR(c) or 'c'                          Grammar.term(Lex.char c)
       | CHARSET(s)                           Grammar.term(Lex.charset s)
       | STRING(s) or "s"                      Grammar.term(Lex.string s)
       | UTF8                               Grammar.term(Lex.any_utf8 ())
       | UTF8(s)                                 Grammar.term(Lex.utf8 s)
       | GRAPHEME                       Grammar.term(Lex.any_grapheme ())
       | GRAPHEME(s)                         Grammar.term(Lex.grapheme s)
       | EOF                                     Grammar.term(Lex.eof ())
       | RE(expr)      Grammar.term(Lex.regexp (Regexp.from_string expr))
       | NAT                                     Grammar.term(Lex.nat ())
       | INT                                     Grammar.term(Lex.int ())
       | FLOAT                                 Grammar.term(Lex.float ())
       | STRING_LIT                       Grammar.term(Lex.string_lit ())
       | CHAR_LIT                           Grammar.term(Lex.char_lit ())
       | RE(expr)      Grammar.term(Lex.regexp (Regexp.from_string expr))
       | ~? expr                                      Grammar.option expr
       | ~? [expr] expr                  Grammar.option_default expr expr
       | ~* expr                                        Grammar.star expr
       | ~* [expr] expr                        Grammar.star_sep expr expr
       | ~+ expr                                        Grammar.plus expr
       | ~+ [expr] expr                        Grammar.plus_sep expr expr
       | other expr                                                itself
epat ::= lid
       | __                                                 encoding of _
       | (lazy epat)
       | (epat : coretype)
       | epat = lid                              encoding of [pat as lid]
       | (epat, ..., epat)
       | uid(epat)
       | M.epat
]}
[epat] correspond to an encoding of patterns in expressions. Beware that [_] is
invalid, use [__] instead. [cond] is an expression using any test operator:
"="|"<"|">"|"<="|">="|"<>"|"=="|"!="|"not"|"&&"|"||".

In action code (expression right of [=>]), a [lid_lpos] or [lid_rpos] will
denote respectively the left and right position of the item named [lid].  a
[lid_pos] will group both [lid_lpos] and [lid_rpos] in a record of type [Pos.t *
Pos.t]. If the item is matched by a tuple and you want to use its position you
must use [pat = lid] syntax to give a name to the whole item.

Action code needs parenthesis or [begin ... end] if it uses [if .. then],
pattern matching or sequences.

Beware that inside the scope of the extension, you can use the syntax for
grammars everywhere. This allows for some nesting as in:
{[
type p = Atom | Prod | Sum
let%parser rec
     expr p = Atom < Prod < Sum
            ; (p=Atom) (x::FLOAT)                        => x
            ; (p=Atom) '(' (e::expr Sum) ')'             => e
            ; (p=Prod) (x::expr Prod) => ( '*' (y::expr Atom) => x*.y
                                         ; '/' (y::expr Atom) => x/.y)
            ; (p=Sum ) (x::expr Sum ) => ('+' (y::expr Prod) => x+.y
                                         ; '-' (y::expr Prod) => x-.y)
]}

But when using this, beware that [x] is not available before the final action
code, it can not be used for selecting  grammar rule. [(p::prio) => (x::g p) => x]
will report [p] as unbounded. To solve this, you can use dependent sequences,
using [(x,y)>:item] will allow [x] (but not [y]) to be used both in the action
and the rule. The separation with dependent and non dependent part is crucial
as dependent grammar are memoised and you don't want "noise". Here is an
example of grammar using this to implement an extensible calculator
(see [tests/calc_ext.ml]):
{[
let%parser rec
 expr pmax = ((pe,e1)>:expr pmax)((pop,b)>:op pe pmax)
               ((__,e2)::expr pop)                => (pop, b e1 e2)
            ; (x::FLOAT)                          => (0.0,x)
            ; '(' (e::expr_top) ')'               => (0.0,e)
]}

Action are evaluated as soon as the rule is reduced. This may be a problem for
grammar whose prefix are ambiguous, even if the grammar is not really ambiguous.
This is notably true for right recursion (which as usual should be avoided). If
nothing is done, right recursion will be quadratic in time while linear in space
and time is exptected (linear space is the reason to prefer left recursion, when
it is possible to get constant space). To delay evaluation of action, you should
use lazy action. For instance, the right recursive grammar for sexpr below:
{[
let%parser rec sexp =
  (x::RE id)         => Idt x
; '(' (l::sexps) ')' => Lst l
and sexps =
  () => lazy []
; (e::sexp) (l::sexps) => (e::l)
]}
Does not work efficiently because in an expression like "a b c ..."
all the lists [[Idt "a"]], [[Idt "a"; Idt "b"]], etc are constructed.
It should be rewritten using [lazy]:
{[
let%parser rec sexp =
  (x::RE id)              => Idt x
; '(' (lazy l::sexps) ')' => Lst l
and sexps =
  ()                        => lazy []
; (e::sexp) (lazy l::sexps) => lazy (e::l)
]}
or left recursion:
{[
let%parser rec sexp =
  (x::RE id)         => Idt x
; '(' (l::sexps) ')' => Lst (List.rev l)
and sexps =
  ()                   => []
; (l::sexps) (e::sexp) => e::l
]}

Remark: there are some important optimisation for [lazy] so use the [lazy]
keyword as above as much as possible and do not use [Lazy.from_fun] or [Lazy.force]
if you can avoid it.

Here are the meaning of let bindings for grammars through the ppx extension:
- non recursive let bindings correspond to just a name for the grammar.
- recursive let bindings correspond either to
  - [Grammar.declare_grammar + Grammar.set_grammar] (if no parameter)
  - [Grammar.grammar_family + setting the grammar] if parameters are given.
    multiple parameter and using label are supported through curryfication
    by the ppx extension.

For recursive grammar with exactly one parameter, a rule [p_1 < p_2 < ... < p_n]
will automatically add rules to include the grammar parametrized by [p_i] in the
grammar parametrized by [p_(i+1)]. This was used by the calculator example above.

[let%parser] accepts the following attribute:
  - [[@cache]] to cache the grammar (that is call [Grammar.cache] on the grammar)
  - [[@merge f]] to apply [f] if two parsetrees are possible for the same input.
    This corresponds to [Grammar.cache ~merge:f].
  - [[@layout blank]] or [[@layout blank ~config:expr]] to apply Grammar.layout
    and change the blank characters for the grammar.
  - [[@print_param f]] to specify a printing function for the parameters of a
    recursive grammar.

Anything which does not correspond to this grammar will be unchanged
in the ocaml code (like the type definition in the example
above).  A mutually recursive definition can also mix the definition of
grammars (parametric of not) with the definition of normal ocaml values.
This means you could put the whole file inside [%%parse ...].

{1:limitations Limitations}

Pacomb must eliminate left recursion in grammars in order to use combinators
that would loop otherwise. However, left recursion is not supported if it
traverses A {!Pacomb.Grammar.layout} constructor to change blanks (probably
possible to solve this, but probably not worth it).

Ambiguous grammar will be analysed in polynomial time if and only if you use
a cache for all ambiguous non terminals of your grammar. Pacomb does perform
some left factorisation, but it is not complete. Using cache is also a solution
to that problem. Pacomb has function to print the grammar to see if left
factorisation was performed.

Note: left recursion do not need and is not eliminated if the grammar uses a
cache. However, this solution to use cache in general is too slow for non
ambiguous grammars so we do not impose a cache to all left recursive grammars.

The ppx extension is not too bad but still suffers from the fact that it uses
a sub-language of OCaml to describe grammars. For instance [let%parser g =
((_,x)::g) => x] is not legal because [_] cannot be used in an Ocaml
expression. Though the following works: [let%parser g = ((__,x)::g) => x].
The syntax [(((x,y) = z) :: g) => (x,y,z_pos)] is not very nice as we
use [=] to replace the [as] keyword and we also need a lot of parentheses.
