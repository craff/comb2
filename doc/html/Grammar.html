<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="next" href="Combinator.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Grammar" rel="Chapter" href="Grammar.html">
<link title="Combinator" rel="Chapter" href="Combinator.html">
<link title="Lex" rel="Chapter" href="Lex.html">
<link title="Regexp" rel="Chapter" href="Regexp.html">
<link title="Input" rel="Chapter" href="Input.html">
<link title="Position" rel="Chapter" href="Position.html">
<link title="Earley" rel="Chapter" href="Earley.html"><link title="Type" rel="Section" href="#2_Type">
<link title="Grammar contructors" rel="Section" href="#2_Grammarcontructors">
<link title="Definition of recursive grammars " rel="Section" href="#2_Definitionofrecursivegrammars">
<link title="Compilation of a grammar and various" rel="Section" href="#2_Compilationofagrammarandvarious">
<title>Grammar</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Combinator.html" title="Combinator">Next</a>
</div>
<h1>Module <a href="type_Grammar.html">Grammar</a></h1>

<pre><span id="MODULEGrammar"><span class="keyword">module</span> Grammar</span>: <code class="code">sig</code> <a href="Grammar.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<h2 id="1_MainmoduleofPacomb">Main module of Pacomb</h2>
<p>PaComb implements a representation  of grammar with semantical action.  A
    semantical action  is a value returned  as result of parsing.  Parsing is
    performed  by compiling  the grammar  to combinators  implemented in  the
    <code class="code">Combinator</code> module. This library offers  "scanner less" parsing, but the
    <code class="code">Lex</code> module  provide a notion of  terminals and blanks which  allows for
    easy way to write grammars in two phases as usual.</p>

<p>Defining languages using directly the  Grammar module leads to cumbersome
    code. This is  why Pacomb propose a  ppx extension that can  be used with
    the compilation flag <code class="code">-ppx pacombPpx</code>. Here is an example:</p>

<pre class="codepre"><code class="code">    [%%parser
       type p = Atom | Prod | Sum
       let rec
         expr p = Atom &lt; Prod &lt; Sum
                ; (p=Atom) (x::FLOAT)                        =&gt; x
                ; (p=Atom) '(' (e::expr Sum) ')'             =&gt; e
                ; (p=Prod) (x::expr Prod) '*' (y::expr Atom) =&gt; x*.y
                ; (p=Prod) (x::expr Prod) '/' (y::expr Atom) =&gt; x/.y
                ; (p=Sum ) (x::expr Sum ) '+' (y::expr Prod) =&gt; x+.y
                ; (p=Sum ) (x::expr Sum ) '-' (y::expr Prod) =&gt; x-.y
    ]</code></pre>
<p>The extension  <code class="code">[%%parser ...]</code> extends  structure with new  let bindings
    defining grammars. This  applies both for <code class="code">let</code> and <code class="code">let  rec</code> the latter
    being  reserved  to recursive  grammars.  We  also provide  an  extension
    <code class="code">[%grammar]</code>  for  expression  that  corresponds to  grammars,  i.e.  the
    right-hand side of binding in the <code class="code">[%%parser]</code> extension.</p>

<p>Here is the BNF for these right-hand-side, with its semantics</p>
<pre class="codepre"><code class="code">    grammar ::= rule                                                   itself
           | grammar ; rule                                       Grammar.alt
    rule ::= qitems =&gt; expr                            A rule with its action
           | expr &lt; ... &lt; expr                       priority order see below
    qitems ::= ()                                               Grammar.empty
           | non_empty_qitems                                          itself
    non_empty_qitems ::= qitem
           | non_empty_qitems qitems                              Grammar.seq
    qitem ::= item | (lid :: item)          give a name if used in the action
    item ::= '...'                                  Grammar.term(Lex.char ())
           | "..."                                Grammar.term(Lex.string ())
           | INT                                     Grammar.term(Lex.int ())
           | FLOAT                                 Grammar.term(Lex.float ())
           | RE(exp)        Grammar.term(Lex.regexp (Regexp.from_string exp))
           | exp                                                       itself
    </code></pre>
<ul>
<li>non recursive let bindings correspond to just a name for the grammar.</li>
<li>recursive let bindings correspond either to</li>
<li><code class="code">declare_grammar + set_grammar</code> (if no paramater)</li>
<li><code class="code">grammar_familly + setting the grammar</code> is a parameter is given.</li>
</ul>
<p>Anything  which  does not  coresponds  to  this  grammar will  we  keeped
    unchanged in the structure as ocaml code (like the type definition in the
    example  above.   A  mutually  recursive   definition  can  also  mix  te
    definition of grammars (parametric of  not) with the definition of normal
    ocaml values.</p>
</div>
</div>
<hr width="100%">
<h3 id="2_Type">Type</h3>
<pre><span id="TYPEgrammar"><span class="keyword">type</span> <code class="type">'a</code> grammar</span> </pre>
<div class="info ">
<div class="info-desc">
<p>type of a grammar with semantical action of type <code class="code">'a </code>.</p>
</div>
</div>


<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> = <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a></code> </pre>
<div class="info ">
<div class="info-desc">
<p>An abbreviation</p>
</div>
</div>

<h3 id="2_Grammarcontructors">Grammar contructors</h3>
<pre><span id="VALprint_grammar"><span class="keyword">val</span> print_grammar</span> : <code class="type">?def:bool -> Stdlib.out_channel -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">print_grammar ch g</code> prints the grammar <code class="code">g</code> of the given output channel.
    if <code class="code">def=false</code> (the default is <code class="code">true</code>) it will print the transformed
    grammar prior to compilation.</p>
</div>
</div>

<pre><span id="VALfail"><span class="keyword">val</span> fail</span> : <code class="type">unit -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">fail ()</code> is a grammar that parses nothing (always fails)</p>
</div>
</div>

<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">'a -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">empty a</code> accepts the empty input and returns <code class="code">a</code></p>
</div>
</div>

<pre><span id="VALtest"><span class="keyword">val</span> test</span> : <code class="type">bool -> unit <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">test b</code> is <code class="code">if b then empty () else fail ()</code>. Very usefull in
    grammar family at the beginning of a rule</p>
</div>
</div>

<pre><span id="VALterm"><span class="keyword">val</span> term</span> : <code class="type">?name:string -> 'a <a href="Lex.html#TYPEterminal">Lex.terminal</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">term t</code> accepts the terminal <code class="code">t</code> and returns its semantics.
    See module <code class="code">Lex</code></p>
</div>
</div>

<pre><span id="VALappl"><span class="keyword">val</span> appl</span> : <code class="type">?name:string -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> ('a -> 'b) -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">appl g f</code> parses with <code class="code">g</code> and apply <code class="code">f</code> to the resulting semantics</p>
</div>
</div>

<pre><span id="VALalt"><span class="keyword">val</span> alt</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">alt g1 g2</code> parses with <code class="code">g1</code> and if it fails then <code class="code">g2</code></p>
</div>
</div>

<pre><span id="VALseq"><span class="keyword">val</span> seq</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -><br>       'b <a href="Grammar.html#TYPEgrammar">grammar</a> -> ('a -> 'b -> 'c) -> 'c <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">seq g1 g2 f</code> parse with g1 and then with g2 for the rest of the input, uses <code class="code">f</code>
    to combine both semantics</p>
</div>
</div>

<pre><span id="VALseq1"><span class="keyword">val</span> seq1</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p>usefull derivations from <code class="code">seq</code></p>
</div>
</div>

<pre><span id="VALseq2"><span class="keyword">val</span> seq2</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre>
<pre><span id="VALseqf"><span class="keyword">val</span> seqf</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> ('a -> 'b) <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre>
<pre><span id="VALdseq"><span class="keyword">val</span> dseq</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -><br>       ('a -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a>) -> ('b -> 'c) -> 'c <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">dseq g1 g2 f)</code> is a dependant sequence, the grammar <code class="code">g2</code> used after <code class="code">g1</code> may
    depend upon the semantics of <code class="code">g1</code>. This is not very efficient as the grammar
    <code class="code">g2</code> must be compiled at parsing time. It is a good idea to memoize <code class="code">g2</code></p>
</div>
</div>

<pre><span id="VALlpos"><span class="keyword">val</span> lpos</span> : <code class="type">(<a href="Position.html#TYPEt">Position.t</a> -> 'a) <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">lpos g</code> is identical to <code class="code">g</code> but passes the position just before parsing with
    <code class="code">g</code> to the semantical action of <code class="code">g</code></p>
</div>
</div>

<pre><span id="VALrpos"><span class="keyword">val</span> rpos</span> : <code class="type">(<a href="Position.html#TYPEt">Position.t</a> -> 'a) <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">rpos g</code> is identical to <code class="code">g</code> but passes the position just after parsing with
    <code class="code">g</code> to the semantical action of <code class="code">g</code></p>
</div>
</div>

<pre><span id="VALseqf_pos"><span class="keyword">val</span> seqf_pos</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -><br>       (<a href="Position.html#TYPEt">Position.t</a> -> 'a -> <a href="Position.html#TYPEt">Position.t</a> -> 'b) <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p>variants of seqf with the position of the first iterm</p>
</div>
</div>

<pre><span id="VALseqf_lpos"><span class="keyword">val</span> seqf_lpos</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -><br>       (<a href="Position.html#TYPEt">Position.t</a> -> 'a -> 'b) <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre>
<pre><span id="VALseqf_rpos"><span class="keyword">val</span> seqf_rpos</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -><br>       ('a -> <a href="Position.html#TYPEt">Position.t</a> -> 'b) <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre>
<pre><span id="VALseq2_pos"><span class="keyword">val</span> seq2_pos</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -><br>       (<a href="Position.html#TYPEt">Position.t</a> -> <a href="Position.html#TYPEt">Position.t</a> -> 'b) <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p>variants of seq2 with the position of the first iterm</p>
</div>
</div>

<pre><span id="VALseq2_lpos"><span class="keyword">val</span> seq2_lpos</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -><br>       (<a href="Position.html#TYPEt">Position.t</a> -> 'b) <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre>
<pre><span id="VALseq2_rpos"><span class="keyword">val</span> seq2_rpos</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -><br>       (<a href="Position.html#TYPEt">Position.t</a> -> 'b) <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre>
<pre><span id="VALcache"><span class="keyword">val</span> cache</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">cache g</code> avoid to parse twice the same input with g by memoizing the result
    of the first parsing. Using <code class="code">cache</code> allows to recover a polynomial complexity</p>
</div>
</div>

<pre><span id="VALlayout"><span class="keyword">val</span> layout</span> : <code class="type">?old_before:bool -><br>       ?new_before:bool -><br>       ?new_after:bool -><br>       ?old_after:bool -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> <a href="Lex.html#TYPEblank">Lex.blank</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">layout g b</code> changes the blank function to parse the input with the
    grammar <code class="code">g</code>. The optional parameters allow to control which blanks are used
    at the bounndary. Both can be used in which case the new blanks are used
    second before parsing with <code class="code">g</code> and first after.</p>
</div>
</div>
<h3 id="2_Definitionofrecursivegrammars">Definition of recursive grammars </h3>
<pre><span id="VALdeclare_grammar"><span class="keyword">val</span> declare_grammar</span> : <code class="type">string -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p>to define recursive grammars, one may declare the grammar first and then
    gives its value.
    <code class="code">declare_grammar name</code> creates an undefined grammar with the given name</p>
</div>
</div>

<pre><span id="VALset_grammar"><span class="keyword">val</span> set_grammar</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">set_grammar g1 g2</code> set the value of <code class="code">g1</code> declared with <code class="code">declare_grammar</code>.
    will raise <code class="code">Invalid_argument</code> if <code class="code">g1</code> was not defined using
    <code class="code">declare_grammar</code> or if it was already set.</p>
</div>
</div>

<pre><span id="VALfixpoint"><span class="keyword">val</span> fixpoint</span> : <code class="type">?name:string -><br>       ('a <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a>) -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">fixpoint g</code> compute the fixpoint of <code class="code">g</code>, that is a grammar <code class="code">g0</code> such that
    <code class="code">g0 = g g0</code></p>
</div>
</div>

<pre><span id="VALgrammar_family"><span class="keyword">val</span> grammar_family</span> : <code class="type">?param_to_string:('a -> string) -><br>       string -> ('a -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a>) * (('a -> 'b <a href="Grammar.html#TYPEgrammar">grammar</a>) -> unit)</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">grammar_family to_str name</code> returns a pair <code class="code">(gs, set_gs)</code>, where <code class="code">gs</code>
    is a finite family of grammars parametrized by a value of type <code class="code">'a</code>. A name
    <code class="code">name</code> is to be provided for the family, and an optional function <code class="code">to_str</code>
    can be provided to print the parameter and display better error messages.</p>
</div>
</div>
<pre class="codepre"><code class="code">   (* Declare the grammar family *)
   let (gr, set_gr) = grammar_family to_str name in

   ... code using grammars of gr to define mutually recursive grammars ...
   ... the grammars in gr cannot be used in "left position" ...
   ... (same restriction as for declare_grammar ...

   (* Define the grammar family *)
   let _ = set_gr the_grammars

   ... now the new family can be used ...
   </code></pre><h3 id="2_Compilationofagrammarandvarious">Compilation of a grammar and various</h3>
<pre><span id="VALcompile"><span class="keyword">val</span> compile</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'a <a href="Combinator.html#TYPEt">Combinator.t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">compile g</code> produces a combinator that can be used to actually do the parsing
    see the <code class="code">Combinator</code> module</p>
</div>
</div>

<pre><span id="VALgrammar_info"><span class="keyword">val</span> grammar_info</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> bool * Charset.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">grammar_info g</code> returns <code class="code">(b,cs)</code> where <code class="code">b</code> is true is the grammar accepts
    the empty input and where <code class="code">cs</code> is the characters set accepted at the beginnning
    of the input.</p>
</div>
</div>

<pre><span id="VALgrammar_name"><span class="keyword">val</span> grammar_name</span> : <code class="type">'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> string</code></pre><div class="info ">
<div class="info-desc">
<p>gives the grammar name</p>
</div>
</div>

<pre><span id="VALgive_name"><span class="keyword">val</span> give_name</span> : <code class="type">string -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a> -> 'a <a href="Grammar.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p>allows to rename a grammar</p>
</div>
</div>
</body></html>
