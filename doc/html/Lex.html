<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Combinator.html">
<link rel="next" href="Regexp.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Grammar" rel="Chapter" href="Grammar.html">
<link title="Combinator" rel="Chapter" href="Combinator.html">
<link title="Lex" rel="Chapter" href="Lex.html">
<link title="Regexp" rel="Chapter" href="Regexp.html">
<link title="Input" rel="Chapter" href="Input.html">
<link title="Position" rel="Chapter" href="Position.html">
<link title="Earley" rel="Chapter" href="Earley.html"><link title="Combinators to create terminals" rel="Section" href="#2_Combinatorstocreateterminals">
<link title="Functions managing blanks" rel="Section" href="#2_Functionsmanagingblanks">
<title>Lex</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Combinator.html" title="Combinator">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Regexp.html" title="Regexp">Next</a>
</div>
<h1>Module <a href="type_Lex.html">Lex</a></h1>

<pre><span id="MODULELex"><span class="keyword">module</span> Lex</span>: <code class="code">sig</code> <a href="Lex.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<h2 id="1_Lexinggroupingcharactersbeforeparsing">Lexing: grouping characters before parsing</h2>
<p>It is traditionnal to do parsing in two phases (scanning/parsing).  This
    is not necessary with combinators in general this is still true with
    Pacomb (scannerless). However, this makes the grammar more readable to
    use a lexing phase.</p>

<p>Moreover, lexing is often done with a longuest match rule that is not
    semantically equivalent to the semantics of context free grammar.</p>

<p>This modules provide combinator to create terminals that the parser
    will call.</p>

<p>It also provide function to eliminate "blank" characteres.</p>
</div>
</div>
<hr width="100%">

<pre><span id="TYPEbuf"><span class="keyword">type</span> <code class="type"></code>buf</span> = <code class="type"><a href="Input.html#TYPEbuffer">Input.buffer</a></code> </pre>
<div class="info ">
<div class="info-desc">
<h3 id="2_Typesandexception">Types and exception</h3></div>
</div>


<pre><span id="TYPEblank"><span class="keyword">type</span> <code class="type"></code>blank</span> = <code class="type"><a href="Lex.html#TYPEbuf">buf</a> -> int -> <a href="Lex.html#TYPEbuf">buf</a> * int</code> </pre>
<div class="info ">
<div class="info-desc">
<p>A blank function is just a function progressing in a buffer</p>
</div>
</div>


<pre><span id="TYPEfterm"><span class="keyword">type</span> <code class="type">'a</code> fterm</span> = <code class="type"><a href="Lex.html#TYPEbuf">buf</a> -> int -> 'a * <a href="Lex.html#TYPEbuf">buf</a> * int</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Type of terminal function, similar to blank, but with a returned value</p>
</div>
</div>


<pre><code><span id="TYPEterminal"><span class="keyword">type</span> <code class="type">'a</code> terminal</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTterminal.n">n</span>&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>name</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTterminal.f">f</span>&nbsp;: <code class="type">'a <a href="Lex.html#TYPEfterm">fterm</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>the terminal itself</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTterminal.c">c</span>&nbsp;: <code class="type">Charset.t</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>the set of characters accepted
                                       at the beginning of input</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>The previous type encapsulated in a record</p>
</div>
</div>


<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> = <code class="type">'a <a href="Lex.html#TYPEterminal">terminal</a></code> </pre>
<div class="info ">
<div class="info-desc">
<p>Abbreviation</p>
</div>
</div>


<pre><span id="EXCEPTIONNoParse"><span class="keyword">exception</span> NoParse</span></pre>
<div class="info ">
<div class="info-desc">
<p>exception when failing,</p>
<ul>
<li>can be raised (but not captured) by terminal</li>
<li>can be raised (but not captured) by action code in the grammar,
      see <code class="code">Combinator.give_up</code></li>
<li>will be raise and captured by <code class="code">Combinator.parse_buffer</code> that will give
      the most advanced position</li>
</ul>
</div>
</div>
<h3 id="2_Combinatorstocreateterminals">Combinators to create terminals</h3>
<pre><span id="VALeof"><span class="keyword">val</span> eof</span> : <code class="type">?name:string -> 'a -> 'a <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Terminal accepting then end of a buffer only.
    remark: <code class="code">eof</code> is automatically added at the end of a grammar by
    <code class="code">Combinator.parse_buffer</code>.
    <code class="code">name</code> default is <code class="code">"EOF"</code></p>
</div>
</div>

<pre><span id="VALchar"><span class="keyword">val</span> char</span> : <code class="type">?name:string -> char -> 'a -> 'a <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Terminal accepting a given char, remark: <code class="code">char '\255'</code> is equivalent to
    <code class="code">eof</code>. <code class="code">name</code> default is the given charater.</p>
</div>
</div>

<pre><span id="VALtest"><span class="keyword">val</span> test</span> : <code class="type">?name:string -> (char -> bool) -> char <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Accept a character for which the test returns <code class="code">true</code>. <code class="code">name</code> default
    to the result of <code class="code">Charset.show</code>.</p>
</div>
</div>

<pre><span id="VALcharset"><span class="keyword">val</span> charset</span> : <code class="type">?name:string -> Charset.t -> char <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Accept a character in the given charset. <code class="code">name</code> default as in <code class="code">test</code></p>
</div>
</div>

<pre><span id="VALnot_test"><span class="keyword">val</span> not_test</span> : <code class="type">?name:string -> (char -> bool) -> 'a -> 'a <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Reject the input (raises <code class="code">Noparse</code>) if the first character of the input
    passed the test. Does not read the character if the test fails.
    <code class="code">name</code> default to <code class="code">"^"</code> prepended to the result of <code class="code">Charset.show</code>.</p>
</div>
</div>

<pre><span id="VALnot_charset"><span class="keyword">val</span> not_charset</span> : <code class="type">?name:string -> Charset.t -> 'a -> 'a <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Reject the input (raises <code class="code">Noparse</code>) if the first character of the input
    is in the charset. Does not read the character if not in the charset.
    <code class="code">name</code> default as in <code class="code">not_test</code></p>
</div>
</div>

<pre><span id="VALseq"><span class="keyword">val</span> seq</span> : <code class="type">?name:string -> 'a <a href="Lex.html#TYPEt">t</a> -> 'b <a href="Lex.html#TYPEt">t</a> -> ('a -> 'b -> 'c) -> 'c <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Compose two terminals in sequence. <code class="code">name</code> default is the concatenation
    of the two names.</p>
</div>
</div>

<pre><span id="VALseq1"><span class="keyword">val</span> seq1</span> : <code class="type">?name:string -> 'a <a href="Lex.html#TYPEt">t</a> -> 'b <a href="Lex.html#TYPEt">t</a> -> 'a <a href="Lex.html#TYPEt">t</a></code></pre>
<pre><span id="VALseq2"><span class="keyword">val</span> seq2</span> : <code class="type">?name:string -> 'a <a href="Lex.html#TYPEt">t</a> -> 'b <a href="Lex.html#TYPEt">t</a> -> 'b <a href="Lex.html#TYPEt">t</a></code></pre>
<pre><span id="VALalt"><span class="keyword">val</span> alt</span> : <code class="type">?name:string -> 'a <a href="Lex.html#TYPEt">t</a> -> 'a <a href="Lex.html#TYPEt">t</a> -> 'a <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">alt t1 t2</code> parses the input with <code class="code">t1</code> or <code class="code">t2</code>.
    Contrary to grammars, terminals does not use continuations,
    if <code class="code">t1</code> succeds, no backtrack will be performed to try <code class="code">t2</code>.
    For instance,
      <code class="code">seq1 (alt (char 'a' ())
                 (seq1 (char 'a' ()) (char 'b' ())))
            (char 'c' ())</code>
    will reject "abc".
    If both <code class="code">t1</code> and <code class="code">t2</code> accept the input, longuest match is selected.
    <code class="code">name</code> default to <code class="code">sprintf "(%s)|(%s)" t1.n t2.n</code>.</p>
</div>
</div>

<pre><span id="VALoption"><span class="keyword">val</span> option</span> : <code class="type">?name:string -> 'a -> 'a <a href="Lex.html#TYPEt">t</a> -> 'a <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">option x t</code> parses the given terminal 0 or 1 time. <code class="code">x</code> is returned if 0.
    <code class="code">name</code> defaults to <code class="code">sprintf "(%s)?" t.n</code>.</p>
</div>
</div>

<pre><span id="VALappl"><span class="keyword">val</span> appl</span> : <code class="type">?name:string -> ('a -> 'b) -> 'a <a href="Lex.html#TYPEt">t</a> -> 'b <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Applies a function to the result of the given terminal.
    <code class="code">name</code> defaults to the terminal name.</p>
</div>
</div>

<pre><span id="VALstar"><span class="keyword">val</span> star</span> : <code class="type">?name:string -> 'a <a href="Lex.html#TYPEt">t</a> -> (unit -> 'b) -> ('b -> 'a -> 'b) -> 'b <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">star t a f</code> Repetition of a given terminal 0,1 or more times.
    The type of function to compose the action allows for <code class="code">'b = Buffer.t</code>
    for efficiency. The returned value is
    <code class="code">f ( ... (f(f (a ()) x_1) x_2) ...) x_n</code>if <code class="code">t</code> returns <code class="code">x_1</code> ... <code class="code">x_n</code>.
    The <code class="code">name</code> defaults to <code class="code">sprintf "(%s)*" t.n</code></p>
</div>
</div>

<pre><span id="VALplus"><span class="keyword">val</span> plus</span> : <code class="type">?name:string -> 'a <a href="Lex.html#TYPEt">t</a> -> (unit -> 'b) -> ('b -> 'a -> 'b) -> 'b <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as above but parses at least once .</p>
</div>
</div>

<pre><span id="VALstring"><span class="keyword">val</span> string</span> : <code class="type">?name:string -> string -> 'a -> 'a <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">string s</code> Accepts only the given string.
    Raises <code class="code">Invalid_argument</code> if <code class="code">s = ""</code>.
    <code class="code">name</code> defaults to <code class="code">sprintf "%S" s</code>.</p>
</div>
</div>

<pre><span id="VALint"><span class="keyword">val</span> int</span> : <code class="type">?name:string -> unit -> int <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Parses an integer in base 10. <code class="code">"+42"</code> is accepted.
    <code class="code">name</code> defaults to <code class="code">"INT"</code></p>
</div>
</div>

<pre><span id="VALfloat"><span class="keyword">val</span> float</span> : <code class="type">?name:string -> unit -> float <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Parses a float in base 10. <code class="code">".1"</code> is not accepted <code class="code">"0.1"</code> is.
    <code class="code">name</code> defaults to <code class="code">"FLOAT"</code></p>
</div>
</div>

<pre><span id="VALkeyword"><span class="keyword">val</span> keyword</span> : <code class="type">?name:string -> string -> (char -> bool) -> 'a -> 'a <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">keyword ~name k cs x =
     seq ~name (string k ()) (test f ()) (fun _ _ -&gt; x)</code>
    usefull to accept a keyword only when not followed by an alpha-numeric char</p>
</div>
</div>

<pre><span id="VALregexp"><span class="keyword">val</span> regexp</span> : <code class="type">?name:string -> <a href="Regexp.html#TYPEt">Regexp.t</a> -> string <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>create a terminal from a regexp. Returns the whole matched string</p>
</div>
</div>

<pre><span id="VALregexp_grps"><span class="keyword">val</span> regexp_grps</span> : <code class="type">?name:string -> <a href="Regexp.html#TYPEt">Regexp.t</a> -> string list <a href="Lex.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>create a terminal from a regexp. Returns the groups list, last to finish
    to be parsed is first in the result</p>
</div>
</div>
<h3 id="2_Functionsmanagingblanks">Functions managing blanks</h3>
<pre><span id="VALnoblank"><span class="keyword">val</span> noblank</span> : <code class="type"><a href="Lex.html#TYPEblank">blank</a></code></pre><div class="info ">
<div class="info-desc">
<p>Use when you have no blank chars</p>
</div>
</div>

<pre><span id="VALblank_charset"><span class="keyword">val</span> blank_charset</span> : <code class="type">Charset.t -> <a href="Lex.html#TYPEblank">blank</a></code></pre><div class="info ">
<div class="info-desc">
<p>Blank from a charset</p>
</div>
</div>

<pre><span id="VALblank_terminal"><span class="keyword">val</span> blank_terminal</span> : <code class="type">'a <a href="Lex.html#TYPEt">t</a> -> <a href="Lex.html#TYPEblank">blank</a></code></pre><div class="info ">
<div class="info-desc">
<p>Blank from a terminal</p>
</div>
</div>

<pre><span id="VALaccept_empty"><span class="keyword">val</span> accept_empty</span> : <code class="type">'a <a href="Lex.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Test wether a terminal accept the empty string. Such a terminal
   are illegal in a grammar, but may be used in combinator below to create
   terminals</p>
</div>
</div>
</body></html>
