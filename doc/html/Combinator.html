<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Grammar.html">
<link rel="next" href="Lex.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Grammar" rel="Chapter" href="Grammar.html">
<link title="Combinator" rel="Chapter" href="Combinator.html">
<link title="Lex" rel="Chapter" href="Lex.html">
<link title="Regexp" rel="Chapter" href="Regexp.html">
<link title="Input" rel="Chapter" href="Input.html">
<link title="Position" rel="Chapter" href="Position.html">
<link title="Earley" rel="Chapter" href="Earley.html"><link title="function and type usefull to the end-user" rel="Section" href="#2_functionandtypeusefulltotheenduser">
<link title="combinator constructors, normally not needed by the casual user " rel="Section" href="#2_combinatorconstructorsnormallynotneededbythecasualuser">
<title>Combinator</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Grammar.html" title="Grammar">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Lex.html" title="Lex">Next</a>
</div>
<h1>Module <a href="type_Combinator.html">Combinator</a></h1>

<pre><span id="MODULECombinator"><span class="keyword">module</span> Combinator</span>: <code class="code">sig</code> <a href="Combinator.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<h2 id="1_Combinatorlibraryusingcontinuation">Combinator library, using continuation</h2>
<p>As usual left recursion is not supported, but the library is intended to
    be used through the <code class="code">Grammar</code> module that provides elimination of left
    recursion. However, a cache combinatr is supported to overcome the cost
    of backtracking.</p>
</div>
</div>
<hr width="100%">
<h3 id="2_functionandtypeusefulltotheenduser">function and type usefull to the end-user</h3>
<pre><span id="TYPEcombinator"><span class="keyword">type</span> <code class="type">'a</code> combinator</span> </pre>
<div class="info ">
<div class="info-desc">
<p>The type of combinator</p>
</div>
</div>


<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> = <code class="type">'a <a href="Combinator.html#TYPEcombinator">combinator</a></code> </pre>
<div class="info ">
<div class="info-desc">
<p>Abbreviation</p>
</div>
</div>


<pre><span id="VALgive_up"><span class="keyword">val</span> give_up</span> : <code class="type">unit -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">give_up ()</code> will reject the current parsing rule from the action code</p>
</div>
</div>

<pre><span id="EXCEPTIONParse_error"><span class="keyword">exception</span> Parse_error</span> <span class="keyword">of</span> <code class="type"><a href="Input.html#TYPEbuffer">Input.buffer</a> * int</code></pre>
<div class="info ">
<div class="info-desc">
<p>Exception raised by the function below when parsing fails</p>
</div>
</div>

<pre><span id="VALhandle_exception"><span class="keyword">val</span> handle_exception</span> : <code class="type">?error:(unit -> 'b) -> ('a -> 'b) -> 'a -> 'b</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">handle_exception fn v</code> applies the function <code class="code">fn</code> to <code class="code">v</code> and handles
    the <code class="code">Parse_error</code> exception. In particular, a parse error message is
    presented to the user in  case  of  a  failure, then <code class="code">error ()</code>
    is called. The default <code class="code">error</code> is <code class="code">fun () -&gt; exit 1</code>.</p>
</div>
</div>

<pre><span id="VALparse_buffer"><span class="keyword">val</span> parse_buffer</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a> -> <a href="Lex.html#TYPEblank">Lex.blank</a> -> <a href="Input.html#TYPEbuffer">Input.buffer</a> -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Parse a whole input buffer. the eof combinator is added at
    the end of the given combinator</p>
</div>
</div>

<pre><span id="VALparse_string"><span class="keyword">val</span> parse_string</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a> -> <a href="Lex.html#TYPEblank">Lex.blank</a> -> string -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Parse a whole string</p>
</div>
</div>

<pre><span id="VALparse_channel"><span class="keyword">val</span> parse_channel</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a> -> <a href="Lex.html#TYPEblank">Lex.blank</a> -> Stdlib.in_channel -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Parse a whole input channel</p>
</div>
</div>

<pre><span id="VALpartial_parse_buffer"><span class="keyword">val</span> partial_parse_buffer</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a> -><br>       <a href="Lex.html#TYPEblank">Lex.blank</a> -><br>       ?blank_after:bool -> <a href="Input.html#TYPEbuffer">Input.buffer</a> -> int -> 'a * <a href="Input.html#TYPEbuffer">Input.buffer</a> * int</code></pre><div class="info ">
<div class="info-desc">
<p>Partial parsing. Beware, the returned position is not the maximum position
    that can be reached by the grammar</p>
</div>
</div>
<h3 id="2_combinatorconstructorsnormallynotneededbythecasualuser">combinator constructors, normally not needed by the casual user </h3>
<pre><span id="VALcfail"><span class="keyword">val</span> cfail</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Always fails</p>
</div>
</div>

<pre><span id="VALcempty"><span class="keyword">val</span> cempty</span> : <code class="type">'a -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Accepting the empty input only</p>
</div>
</div>

<pre><span id="VALcterm"><span class="keyword">val</span> cterm</span> : <code class="type">'a <a href="Lex.html#TYPEfterm">Lex.fterm</a> -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Accepts a given terminal</p>
</div>
</div>

<pre><span id="VALcseq"><span class="keyword">val</span> cseq</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a> -> 'b <a href="Combinator.html#TYPEt">t</a> -> ('a -> 'b -> 'c) -> 'c <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Sequence of two combinators, parses with the first and then parses the
    rest of the input with the second combinator. The last function
    is used to compose the semantics returned by the two combinators.</p>
</div>
</div>

<pre><span id="VALcdep_seq"><span class="keyword">val</span> cdep_seq</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a> -> ('a -> 'b <a href="Combinator.html#TYPEt">t</a>) -> ('b -> 'c) -> 'c <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">sdep_seq c1 c2 f</code> is a dependant sequence, contrary to <code class="code">seq c1 c2 f</code>,
    the combinator used to parse after <code class="code">c1</code> depends upon the value
    returned by <code class="code">c1</code>. It s a good idea to memoize the function c2.</p>
</div>
</div>

<pre><span id="VALcalt"><span class="keyword">val</span> calt</span> : <code class="type">?cs1:Charset.t -><br>       ?cs2:Charset.t -> 'a <a href="Combinator.html#TYPEt">t</a> -> 'a <a href="Combinator.html#TYPEt">t</a> -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Combinator parsing with the first combinator and in case
    of failure with the second from the same position.
    The optionnal charset corresponds to the charaters accepted
    at the beginning of the input for each combinators.
    The charset must be Charset.full if the corresponding combinator
    accept the empty input</p>
</div>
</div>

<pre><span id="VALcapp"><span class="keyword">val</span> capp</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a> -> ('a -> 'b) -> 'b <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Parses with the given combinator and transforms the semantics with
    the given function</p>
</div>
</div>

<pre><span id="VALclpos"><span class="keyword">val</span> clpos</span> : <code class="type">(<a href="Position.html#TYPEt">Position.t</a> -> 'a) <a href="Combinator.html#TYPEt">t</a> -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Parses as the given combinator and give the position
    to the left of the parsing input as argument to the action</p>
</div>
</div>

<pre><span id="VALcpush"><span class="keyword">val</span> cpush</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a> -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>To eliminate left recursion, lpos has to be left factored.
    if lpos is one single combinator, this adds a lot of closures
    in action code. To solve this problem, lpos is splitted in
    two combinators, one that pushes the position to a stack and pops
    after parsing and another that reads the position.</p>
</div>
</div>

<pre><span id="VALcread"><span class="keyword">val</span> cread</span> : <code class="type">int -> (<a href="Position.html#TYPEt">Position.t</a> -> 'a) <a href="Combinator.html#TYPEt">t</a> -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre>
<pre><span id="VALcrpos"><span class="keyword">val</span> crpos</span> : <code class="type">(<a href="Position.html#TYPEt">Position.t</a> -> 'a) <a href="Combinator.html#TYPEt">t</a> -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as above with the position to the right</p>
</div>
</div>

<pre><span id="VALclr"><span class="keyword">val</span> clr</span> : <code class="type">?cs2:Charset.t -><br>       'a <a href="Combinator.html#TYPEt">t</a> -> ('a -> 'a) <a href="Combinator.html#TYPEt">t</a> -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">cls c1 c2</code> is an optimized version of <code class="code">let rec r = seq c1 (seq r c2)</code>
    which is illegal as it is left recursive and loops. The optional charset indicates
    the characteres accepted by <code class="code">c2</code> at the beginning of input.</p>
</div>
</div>

<pre><span id="VALcref"><span class="keyword">val</span> cref</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a> Stdlib.ref -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Access to a reference to a combinator, use by Grammar.compile
    for recursive grammars (not for left recursion</p>
</div>
</div>

<pre><span id="VALclayout"><span class="keyword">val</span> clayout</span> : <code class="type">?old_before:bool -><br>       ?new_before:bool -><br>       ?new_after:bool -><br>       ?old_after:bool -> 'a <a href="Combinator.html#TYPEt">t</a> -> <a href="Lex.html#TYPEblank">Lex.blank</a> -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Change the blank function used to parse with the given combinator.
    we can choose which blank to use at the boundary with the optional
    parameters.</p>
</div>
</div>

<pre><span id="VALccache"><span class="keyword">val</span> ccache</span> : <code class="type">'a <a href="Combinator.html#TYPEt">t</a> -> 'a <a href="Combinator.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Combinator that caches a grammar to avoid exponential behavior.
    parsing with the grammar from each position is memoized to avoid
    parsing twice the same sequence with the same grammar.</p>
</div>
</div>
</body></html>
