<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Position.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Grammar" rel="Chapter" href="Grammar.html">
<link title="Combinator" rel="Chapter" href="Combinator.html">
<link title="Lex" rel="Chapter" href="Lex.html">
<link title="Regexp" rel="Chapter" href="Regexp.html">
<link title="Input" rel="Chapter" href="Input.html">
<link title="Position" rel="Chapter" href="Position.html">
<link title="Earley" rel="Chapter" href="Earley.html"><link title="Types and exceptions" rel="Section" href="#2_Typesandexceptions">
<link title="Atomic parsers" rel="Section" href="#2_Atomicparsers">
<link title="Blanks management" rel="Section" href="#2_Blanksmanagement">
<link title="Support for recursive grammars" rel="Section" href="#2_Supportforrecursivegrammars">
<link title="Parsing functions" rel="Section" href="#2_Parsingfunctions">
<link title="Debuging and flags" rel="Section" href="#2_Debugingandflags">
<link title="Greedy combinator" rel="Section" href="#2_Greedycombinator">
<link title="Sequencing combinators" rel="Section" href="#2_Sequencingcombinators">
<title>Earley</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Position.html" title="Position">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Earley.html">Earley</a></h1>

<pre><span id="MODULEEarley"><span class="keyword">module</span> Earley</span>: <code class="code">sig</code> <a href="Earley.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<h2 id="1_EarleycompatibleinterfaceUNFINISHED">Earley compatible interface (UNFINISHED) </h2></div>
</div>
<hr width="100%">
<p>Earley is a parser combinator library implemented using  the  Earley
    algorithm. This modules is an UNFINISHED WORK to provide an Earley
    compatible interface to Pacomb</p>
<h3 id="2_Typesandexceptions">Types and exceptions</h3>
<pre><span id="TYPEgrammar"><span class="keyword">type</span> <code class="type">'a</code> grammar</span> </pre>
<div class="info ">
<div class="info-desc">
<p>Type of a parser (or grammar) producing a value of type <code class="code">'a</code>.</p>
</div>
</div>


<pre><span id="TYPEblank"><span class="keyword">type</span> <code class="type"></code>blank</span> = <code class="type"><a href="Input.html#TYPEbuffer">Input.buffer</a> -> int -> <a href="Input.html#TYPEbuffer">Input.buffer</a> * int</code> </pre>
<div class="info ">
<div class="info-desc">
<p>As <code class="code">Earley</code> does scannerless parsing, a notion of  <code class="code">blank</code>  function
    is used to discard meaningless parts of the input (e.g. comments  or
    spaces). A <code class="code">blank</code> function takes as input a <code class="code">buffer</code> and a position
    (represented as an <code class="code">int</code>) and returns a couple of a <code class="code">buffer</code>  and  a
    position corresponding to the next meaningful character.</p>

<p>WARNING: a blank function must return a normalized pair (b,p),
    which means 0 &lt;= p &lt; Input.line_num b. You can use Input.normalize
    to ensure this.</p>
</div>
</div>


<pre><span id="EXCEPTIONParse_error"><span class="keyword">exception</span> Parse_error</span> <span class="keyword">of</span> <code class="type"><a href="Input.html#TYPEbuffer">Input.buffer</a> * int</code></pre>
<div class="info ">
<div class="info-desc">
<p>The exception <code class="code">Parse_error(buf,pos,msgs)</code> is raised whenever parsing
    fails. It contains the position <code class="code">pos</code> (and the corresponding  buffer
    <code class="code">buf</code>) of the furthest reached position in the input.</p>
</div>
</div>

<pre><span id="VALgive_up"><span class="keyword">val</span> give_up</span> : <code class="type">unit -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">give_up ()</code> can be called by the user to force the parser to reject
    a possible parsing rule.</p>
</div>
</div>

<pre><span id="VALhandle_exception"><span class="keyword">val</span> handle_exception</span> : <code class="type">?error:(unit -> 'b) -> ('a -> 'b) -> 'a -> 'b</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">handle_exception fn v</code> applies the function <code class="code">fn</code> to <code class="code">v</code> and handles
    the <code class="code">Parse_error</code> exception. In particular, a parse error message is
    presented to the user in  case  of  a  failure, then <code class="code">error ()</code>
    is called. The default <code class="code">error</code> is <code class="code">fun () -&gt; exit 1</code>.</p>
</div>
</div>
<h3 id="2_Atomicparsers">Atomic parsers</h3>
<pre><span id="VALchar"><span class="keyword">val</span> char</span> : <code class="type">?name:string -> char -> 'a -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">char ~name c v</code> is a grammar that accepts only the  character  <code class="code">c</code>,
    and returns <code class="code">v</code> as a semantic value. An optional <code class="code">name</code> can be given
    to the grammar for reference in error messages.</p>
</div>
</div>

<pre><span id="VALstring"><span class="keyword">val</span> string</span> : <code class="type">?name:string -> string -> 'a -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">string s v</code> is a grammar that accepts only the  string  <code class="code">str</code>,  and
    returns <code class="code">v</code> as a semantic value. An optional <code class="code">name</code> can be given  to
    the grammar for reference in error messages.</p>
</div>
</div>

<pre><span id="VALkeyword"><span class="keyword">val</span> keyword</span> : <code class="type">?name:string -> string -> (char -> bool) -> 'a -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">keyword s forbidden v</code> is simalar to string, but the parsing fails
    if <code class="code">forbidden c</code> returns <code class="code">true</code> when <code class="code">c</code> is the next available
    character.</p>
</div>
</div>

<pre><span id="VALeof"><span class="keyword">val</span> eof</span> : <code class="type">'a -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">eof v</code> is a grammar that only accepts the end of file  and  returns
    <code class="code">v</code> as a semantic value. Note that the end of file can be parsed one
    or more times (i.e. the input ends with infinitely many end of  file
    symbols.</p>
</div>
</div>

<pre><span id="VALany"><span class="keyword">val</span> any</span> : <code class="type">char <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">any</code> is a grammar that accepts a single character (but fails on the
    end of file) and returns its value.</p>
</div>
</div>

<pre><span id="VALin_charset"><span class="keyword">val</span> in_charset</span> : <code class="type">?name:string -> Charset.charset -> char <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">in_charset cs</code> is a grammar that parses any character of  the  <code class="code">cs</code>
    charset, and returns its value. An optional <code class="code">name</code> can be  given  to
    the grammar for reference in error messages.</p>
</div>
</div>
<p><code class="code">not_in_charset cs</code> is similar to  <code class="code">in_charset cs</code>  but  it  accepts
    the characters that are not in <code class="code">cs</code>.</p>
<p><code class="code">blank_not_in_charset cs</code> is the same as <code class="code">not_in_charset</code> but
    testing with blank_test.</p>

<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">'a -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">empty v</code> is a grammar that does not parse anything and returns  <code class="code">v</code>
    as a semantic value. Note that this grammar never fails.</p>
</div>
</div>

<pre><span id="TYPEfpos"><span class="keyword">type</span> <code class="type">'a</code> fpos</span> = <code class="type"><a href="Input.html#TYPEbuffer">Input.buffer</a> -> int -> <a href="Input.html#TYPEbuffer">Input.buffer</a> -> int -> 'a</code> </pre>
<div class="info ">
<div class="info-desc">
<p>type for a function waiting for the start and end positions
    (i.e. buffer and index) of an item, in general resulting from parsing</p>
</div>
</div>

<p><code class="code">empty_pos v</code> is similar to the above except that the action
    wait for the position of a complete sequence build using
     <code class="code">fsequence</code> of <code class="code">sequence</code>.</p>

<p>For instance, <code class="code">sequence_position g1 g2 f</code> below can be defined
     as <code class="code">fsequence g1 (fsequence g2 (empty_pos f'))</code>.
     where <code class="code">f' = fun b p b' p' a2 a1 = f b p b' p' a1 a2</code> to give
     the result of g1 and g2 in the expected order.</p>

<pre><span id="VALfail"><span class="keyword">val</span> fail</span> : <code class="type">unit -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">fail ()</code> is a grammar that always fail, whatever the input.</p>
</div>
</div>
<p><code class="code">black_box fn cs accept_empty name</code> is a grammar that uses the
    function <code class="code">fn</code> to parses the input buffer. <code class="code">fn buf pos</code> should
    start parsing <code class="code">buf</code> at position <code class="code">pos</code>, and return a couple
    containing the new buffer and position of the first unread
    character. The character set <code class="code">cs</code> must contain at least the
    characters that are accepted as first character by <code class="code">fn</code>, and no
    less. The boolean <code class="code">accept_empty</code> must be true if the function
    accept the empty string. The <code class="code">name</code> argument is used for reference
    in error messages. Note that the functon <code class="code">fn</code> should use <code class="code">give_up ()</code>
    in case of a parse error.</p>

<p>WARNING: fn must return a triple (x,b,p) when (b,p) is normalized,
    which means 0 &lt;= p &lt; Input.line_num b. You can use Input.normalize to
    ensure this.</p>
<p><code class="code">debug msg</code> is a dummy grammar that always succeeds and prints <code class="code">msg</code>
    on <code class="code">stderr</code> when used. It is useful for debugging.</p>

<pre><span id="VALregexp"><span class="keyword">val</span> regexp</span> : <code class="type">?name:string -> string -> string array <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">regexp ?name re</code> is a grammar that uses the regexp <code class="code">re</code> to parse
    the input buffer. The value returnes is the array of the contents
    of the groups.</p>
</div>
</div>
<h3 id="2_Blanksmanagement">Blanks management</h3>
<pre><span id="VALno_blank"><span class="keyword">val</span> no_blank</span> : <code class="type"><a href="Earley.html#TYPEblank">blank</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">no_blank</code> is a <code class="code">blank</code> function that does not discard any character
    of the input buffer.</p>
</div>
</div>
<p><code class="code">blank_regexp re</code> builds a blank from the regexp <code class="code">re</code>.</p>
<p><code class="code">blank_grammar gr bl</code> produces a <code class="code">blank</code> function using the  grammar
    <code class="code">gr</code> and the <code class="code">blank</code> function <code class="code">bl</code>. It parses as much of  the  input
    as possible using the grammar <code class="code">gr</code> with the <code class="code">blank</code>  function  <code class="code">bl</code>,
    and returns the reached position.</p>
<p><code class="code">change_layout ~old_blank_before  ~new_blank_after  gr bl</code>  replaces
    the current  <code class="code">blank</code>  function with <code class="code">bl</code>,  while  parsing  using the
    grammar <code class="code">gr</code>.  The optional  parameter <code class="code">old_blank_before</code> (<code class="code">true</code> by
    default)  forces the application of the old blank  function,  before
    starting to parse with  <code class="code">gr</code>.  Note  that the new blank  function is
    always called before the first terminal of <code class="code">gr</code>. Similarly, the opt-
    -ional parameter <code class="code">new_blank_after</code> (<code class="code">true</code> by default) forces a call
    to the new blank function after the end of the parsing of <code class="code">gr</code>. Note
    that the old blank function is always called after the last terminal.</p>
<p><code class="code">change_layout ~oba gr bl</code> same as abobe but with no blank.  It
    keeps the first char prediction and is therefore more efficient</p>
<h3 id="2_Supportforrecursivegrammars">Support for recursive grammars</h3>
<pre><span id="VALdeclare_grammar"><span class="keyword">val</span> declare_grammar</span> : <code class="type">string -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">declare_grammar name</code> returns a new grammar that can be used in the
    definition of other grammars, but that cannot be run on input before
    it has been initialized with <code class="code">set_grammar</code>. The <code class="code">name</code>  argument  is
    used for reference to the grammar in error messages.</p>
</div>
</div>

<pre><span id="VALset_grammar"><span class="keyword">val</span> set_grammar</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -> 'a <a href="Earley.html#TYPEgrammar">grammar</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">set_grammar gr grdef</code> set the definiton of grammar <code class="code">gr</code> (previously
    declared with <code class="code">declare_grammar</code>) to be  <code class="code">grdef</code>.  <code class="code">Invalid_argument</code>
    is raised if <code class="code">set_grammar</code> is used on a grammar that was not created
    with <code class="code">declare_grammar</code>. The behavious is undefined if a  grammar  is
    set twice with <code class="code">set_grammar</code>.</p>
</div>
</div>
<h3 id="2_Parsingfunctions">Parsing functions</h3>
<pre><span id="VALparse_buffer"><span class="keyword">val</span> parse_buffer</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -> <a href="Earley.html#TYPEblank">blank</a> -> <a href="Input.html#TYPEbuffer">Input.buffer</a> -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">parse_buffer gr bl buf</code> parses the buffer <code class="code">buf</code> using  the  grammar
    <code class="code">gr</code> and the blank function <code class="code">bl</code>. The exception <code class="code">Parse_error</code> may be
    raised in case of error.</p>
</div>
</div>

<pre><span id="VALparse_string"><span class="keyword">val</span> parse_string</span> : <code class="type">?filename:string -> 'a <a href="Earley.html#TYPEgrammar">grammar</a> -> <a href="Earley.html#TYPEblank">blank</a> -> string -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">parse_string ~filename gr bl str</code> parses the string <code class="code">str</code> using the
    grammar <code class="code">gr</code> and the blank function <code class="code">bl</code>. An optional <code class="code">filename</code> can
    be provided for reference  to  the  input  in  error  messages.  The
    exception <code class="code">Parse_error</code> may be raised in case of error.</p>
</div>
</div>

<pre><span id="VALparse_channel"><span class="keyword">val</span> parse_channel</span> : <code class="type">?filename:string -><br>       'a <a href="Earley.html#TYPEgrammar">grammar</a> -> <a href="Earley.html#TYPEblank">blank</a> -> Stdlib.in_channel -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">parse_channel ~filename gr bl ch</code> parses the contenst of  the  input
    channel <code class="code">ch</code> using the grammar <code class="code">gr</code> and the blank  function  <code class="code">bl</code>.  A
    <code class="code">filename</code> can be provided for reference to the input in case  of  an
    error. <code class="code">parse_channel</code> may raise the <code class="code">Parse_error</code> exception.</p>
</div>
</div>

<pre><span id="VALparse_file"><span class="keyword">val</span> parse_file</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -> <a href="Earley.html#TYPEblank">blank</a> -> string -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">parse_file gr bl fn</code> parses the file <code class="code">fn</code> using the grammar <code class="code">gr</code> and
    the blank function <code class="code">bl</code>. The exception <code class="code">Parse_error</code> may be raised in
    case of error.</p>
</div>
</div>

<pre><span id="VALpartial_parse_buffer"><span class="keyword">val</span> partial_parse_buffer</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -><br>       <a href="Earley.html#TYPEblank">blank</a> -><br>       ?blank_after:bool -> <a href="Input.html#TYPEbuffer">Input.buffer</a> -> int -> 'a * <a href="Input.html#TYPEbuffer">Input.buffer</a> * int</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">partial_parse_buffer gr bl buf pos</code> parses  input  from  the  buffer
    <code class="code">buf</code> starting a position <code class="code">pos</code>, using the grammar <code class="code">gr</code> and the blank
    function <code class="code">bl</code>. A triple is returned containing the  new  buffer,  the
    position that was reached during parsing, and the semantic result  of
    the parsing. The optional argument <code class="code">blank_after</code>, <code class="code">true</code> by default,
    indicates if the returned position if after the final blank or not.
    Note that this function should not be used in the  defi-
    nition of a grammar using the <code class="code">black_box</code> function.</p>
</div>
</div>
<p>A functor providing support for using and <code class="code">Input</code> preprocessor.</p>
<h3 id="2_Debugingandflags">Debuging and flags</h3>
<pre><span id="VALdebug_lvl"><span class="keyword">val</span> debug_lvl</span> : <code class="type">int Stdlib.ref</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">debug_lvl</code> is a flag that can be set for <code class="code">Earley</code> to display  debug
    data on <code class="code">stderr</code>. The default value is <code class="code">0</code>, and bigger numbers acti-
    vate more and more debuging informations.</p>
</div>
</div>

<pre><span id="VALwarn_merge"><span class="keyword">val</span> warn_merge</span> : <code class="type">bool Stdlib.ref</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">warn_merge</code> is a flag that is used to choose whether  warnings  are
    displayed or not when an ambiguity is encountered while parsing. The
    default value is <code class="code">true</code>.</p>
</div>
</div>
<p><code class="code">keep_all_names</code> is false by default and allow for inlining  grammar
    with a name to optimise parsing.  When debugging,  it is possible to
    set it to true  (before all grammar constructions) for more accurate
    messages.</p>
<h3 id="2_Greedycombinator">Greedy combinator</h3>
<pre><span id="VALgreedy"><span class="keyword">val</span> greedy</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">greedy g</code> parses g in a greedy way: only the longest match is considered.
    Still ambigous if the longest match is not unique</p>
</div>
</div>
<h3 id="2_Sequencingcombinators">Sequencing combinators</h3>
<pre><span id="VALsequence"><span class="keyword">val</span> sequence</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -><br>       'b <a href="Earley.html#TYPEgrammar">grammar</a> -> ('a -> 'b -> 'c) -> 'c <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">sequence g1 g2 f</code> is a grammar that first parses using <code class="code">g1</code>, and then
    parses using <code class="code">g2</code>. The results of the sequence is then obtained by applying
    <code class="code">f</code> to the results of <code class="code">g1</code> and <code class="code">g2</code>.</p>
</div>
</div>
<p><code class="code">sequence_position g1 g2 f</code> is a grammar that first parses using <code class="code">g1</code>, and
    then parses using <code class="code">g2</code>. The results of the sequence is then obtained by
    applying <code class="code">f</code> to the results of <code class="code">g1</code> and <code class="code">g2</code>, and to the positions (i.e.
    buffer and index) of the corresponding parsed input.</p>

<p>Remark: <code class="code">sequence g1 g2 f</code> is equivalent to
    <code class="code">sequence_position g1 g2 (fun _ _ _ _ -&gt; f)</code>.</p>

<pre><span id="VALfsequence"><span class="keyword">val</span> fsequence</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -> ('a -> 'b) <a href="Earley.html#TYPEgrammar">grammar</a> -> 'b <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">fsequence g1 g2</code> is a grammar that first parses using <code class="code">g1</code>, and then
    parses using <code class="code">g2</code>. The results of the sequence is then obtained by applying
    the result of <code class="code">g1</code> to the result of <code class="code">g2</code>.</p>

<p>Remark: <code class="code">fsequence g1 g2</code> is equivalent to
    <code class="code">sequence g1 g2 (fun x f -&gt; f x)</code>.</p>
</div>
</div>
<p>same as fsequence, but the result of <code class="code">g2</code> also receive the position of the
    result of <code class="code">g1</code>.</p>

<pre><span id="VALfsequence_ignore"><span class="keyword">val</span> fsequence_ignore</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -> 'b <a href="Earley.html#TYPEgrammar">grammar</a> -> 'b <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p>same as fsequence, but the result of <code class="code">g2</code> receives nothing, meaning
    we forget the result of <code class="code">g1</code>.</p>
</div>
</div>

<pre><span id="VALsequence3"><span class="keyword">val</span> sequence3</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -><br>       'b <a href="Earley.html#TYPEgrammar">grammar</a> -><br>       'c <a href="Earley.html#TYPEgrammar">grammar</a> -> ('a -> 'b -> 'c -> 'd) -> 'd <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">sequence3</code> is similar to <code class="code">sequence</code>, but it composes three grammars into
    a sequence.</p>

<p>Remark: <code class="code">sequence3 g1 g2 g3 f</code> is equivalent to
    <code class="code">sequence (sequence g1 g2 f) g3 (fun f x -&gt; f x)</code>.</p>
</div>
</div>

<pre><span id="VALsimple_dependent_sequence"><span class="keyword">val</span> simple_dependent_sequence</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -> ('a -> 'b <a href="Earley.html#TYPEgrammar">grammar</a>) -> 'b <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">simple_dependent_sequence g1 g2</code> is a grammar that first parses using <code class="code">g1</code>,
    which returns a value <code class="code">a</code>, and then continues to parse with <code class="code">g2 a</code> and
    return its result.</p>
</div>
</div>
<p><code class="code">dependent_sequence g1 g2</code> is a grammar that first parses using <code class="code">g1</code>,
    which returns a value <code class="code">(a,b)</code>, and then continues to parse with <code class="code">g2 a</code> and
    return its result applied to <code class="code">b</code>. compared to the above function, allow
    memoizing the second grammar</p>
<p>= fun g -&gt; dependent_sequence g (fun x -&gt; x)</p>
<p><code class="code">option v g</code> tries to parse the input as <code class="code">g</code>, and returns <code class="code">v</code> in case of
    failure.</p>

<pre><span id="VALfixpoint"><span class="keyword">val</span> fixpoint</span> : <code class="type">'a -> ('a -> 'a) <a href="Earley.html#TYPEgrammar">grammar</a> -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">fixpoint v g</code> parses a repetition of one or more times the input parsed
    by <code class="code">g</code>. The value <code class="code">v</code> is used as the initial value (i.e. to finish the
    sequence).</p>

<p>if parsing X with g returns a function gX, parsing X Y Z with fixpoint a g
    will return gX (gY (gZ a)).</p>

<p>This consumes stack proportinal to the input length ! use revfixpoint ...</p>
</div>
</div>
<p>as <code class="code">fixpoint</code> but parses at leat once with the given grammar</p>
<p><code class="code">listN g sep</code> parses sequences of <code class="code">g</code> separated by  <code class="code">sep</code> of length at
    least <code class="code">N</code>, for <code class="code">N=0,1</code> or <code class="code">2</code>.</p>

<pre><span id="VALalternatives"><span class="keyword">val</span> alternatives</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> list -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">alternatives [g1;...;gn]</code> tries to parse using all the grammars
    <code class="code">[g1;...;gn]</code> and keeps only the first success.</p>
</div>
</div>

<pre><span id="VALapply"><span class="keyword">val</span> apply</span> : <code class="type">('a -> 'b) -> 'a <a href="Earley.html#TYPEgrammar">grammar</a> -> 'b <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">apply f g</code> applies function <code class="code">f</code> to the value returned by the grammar
    <code class="code">g</code>.</p>
</div>
</div>
<p><code class="code">apply_position f g</code> applies function <code class="code">f</code> to the value returned by the
    grammar <code class="code">g</code> and the positions at the beginning and at the end of the
    input parsed input.</p>
<p><code class="code">position g</code> tranforms the grammar <code class="code">g</code> to add information about the
    position of the parsed text.</p>
<p><code class="code">test c f</code> perform a test <code class="code">f</code> on the input buffer. Do not parse
    anything (position are unchanged). The charset <code class="code">c</code> should contains
    all character accepted as at the position given to f</p>
<p><code class="code">blank_test c f</code> same as above except that <code class="code">f</code> is applied to
    <code class="code">buf' pos' buf pos</code> where <code class="code">(buf', pos')</code> is the position before the
    blank. The charset c should contains all character accepted as at
    the position (buf,pos). This allow to test the presence of blank
    or even to read the blank and return some information</p>
<p>a test that fails if there is no blank</p>
<p>a test that fails if there are some blank</p>

<pre><span id="VALgrammar_family"><span class="keyword">val</span> grammar_family</span> : <code class="type">?param_to_string:('a -> string) -><br>       string -> ('a -> 'b <a href="Earley.html#TYPEgrammar">grammar</a>) * (('a -> 'b <a href="Earley.html#TYPEgrammar">grammar</a>) -> unit)</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">grammar_family to_str name</code> returns a pair <code class="code">(gs, set_gs)</code>, where <code class="code">gs</code>
    is a finite family of grammars parametrized by a value of type <code class="code">'a</code>. A name
    <code class="code">name</code> is to be provided for the family, and an optional function <code class="code">to_str</code>
    can be provided to print the parameter and display better error messages.</p>
</div>
</div>
<pre class="codepre"><code class="code">   (* Declare the grammar family *)
   let (gr, set_gr) = grammar_family to_str name in

   ... code using grammars of gr to define mutually recursive grammars ...
   ... the grammars in gr cannot be used in "left position" ...
   ... (same restriction as for declare_grammar ...

   (* Define the grammar family *)
   let _ = set_gr the_grammars

   ... now the new family can be used ...
   </code></pre>
<pre><span id="VALgrammar_prio"><span class="keyword">val</span> grammar_prio</span> : <code class="type">?param_to_string:('b -> string) -><br>       string -><br>       ('b -> 'c <a href="Earley.html#TYPEgrammar">grammar</a>) *<br>       ((('b -> bool) * 'c <a href="Earley.html#TYPEgrammar">grammar</a>) list * ('b -> 'c <a href="Earley.html#TYPEgrammar">grammar</a> list) -><br>        unit)</code></pre><div class="info ">
<div class="info-desc">
<p>Similar to the previous one, with an optimization.
    <code class="code">grammar_prio to_str name</code> returns a pair <code class="code">(gs, set_gs)</code>, where
    <code class="code">gs</code> is a finite family of grammars parametrized by a value of type <code class="code">'a</code>.
    <code class="code">set_gs</code> requires two lists of grammars to set the value of the grammar:</p>
<ul>
<li>the first list are grammar that can only be activated by the parameter
      (if the given function return true)</li>
<li>the second list is used as for grammar family</li>
</ul>
</div>
</div>

<pre><span id="VALgrammar_prio_family"><span class="keyword">val</span> grammar_prio_family</span> : <code class="type">?param_to_string:('a * 'b -> string) -><br>       string -><br>       ('a -> 'b -> 'c <a href="Earley.html#TYPEgrammar">grammar</a>) *<br>       (('a -><br>         (('b -> bool) * 'c <a href="Earley.html#TYPEgrammar">grammar</a>) list * ('b -> 'c <a href="Earley.html#TYPEgrammar">grammar</a> list)) -><br>        unit)</code></pre><div class="info ">
<div class="info-desc">
<p>A mixture of the two above</p>
</div>
</div>

<pre><span id="VALaccept_empty"><span class="keyword">val</span> accept_empty</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">accept_empty g</code> returns <code class="code">true</code> if the grammar <code class="code">g</code> accepts the empty input
    and <code class="code">false</code> otherwise.</p>
</div>
</div>

<pre><span id="VALgrammar_info"><span class="keyword">val</span> grammar_info</span> : <code class="type">'a <a href="Earley.html#TYPEgrammar">grammar</a> -> bool * Charset.t</code></pre>
<pre><span id="VALgive_name"><span class="keyword">val</span> give_name</span> : <code class="type">string -> 'a <a href="Earley.html#TYPEgrammar">grammar</a> -> 'a <a href="Earley.html#TYPEgrammar">grammar</a></code></pre><div class="info ">
<div class="info-desc">
<p>give a name to the grammar. Usefull for debugging.</p>
</div>
</div>
</body></html>
