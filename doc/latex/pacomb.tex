\documentclass[11pt]{article} 
\usepackage[latin1]{inputenc} 
\usepackage[T1]{fontenc} 
\usepackage{textcomp}
\usepackage{fullpage} 
\usepackage{url} 
\usepackage{ocamldoc}
\begin{document}
\tableofcontents
\section{Module {\tt{Grammar}} : Main module of Pacomb}
\label{module:Grammar}\index{Grammar@\verb`Grammar`}



    PaComb implements a representation  of grammar with semantical action.  A
    semantical action  is a value returned  as result of parsing.  Parsing is
    performed  by compiling  the grammar  to combinators  implemented in  the
    {\tt{Combinator}} module. This library offers  "scanner less" parsing, but the
    {\tt{Lex}} module  provide a notion of  terminals and blanks which  allows for
    easy way to write grammars in two phases as usual.


    Defining languages using directly the  Grammar module leads to cumbersome
    code. This is  why Pacomb propose a  ppx extension that can  be used with
    the compilation flag {\tt{-ppx pacombPpx}}. Here is an example:


    \begin{ocamldoccode}

    [%%parser
       type p = Atom | Prod | Sum
       let rec
         expr p = Atom < Prod < Sum
                ; (p=Atom) (x::FLOAT)                        => x
                ; (p=Atom) {\textquotesingle}({\textquotesingle} (e::expr Sum) {\textquotesingle}){\textquotesingle}             => e
                ; (p=Prod) (x::expr Prod) {\textquotesingle}*{\textquotesingle} (y::expr Atom) => x*.y
                ; (p=Prod) (x::expr Prod) {\textquotesingle}/{\textquotesingle} (y::expr Atom) => x/.y
                ; (p=Sum ) (x::expr Sum ) {\textquotesingle}+{\textquotesingle} (y::expr Prod) => x+.y
                ; (p=Sum ) (x::expr Sum ) {\textquotesingle}-{\textquotesingle} (y::expr Prod) => x-.y
    ]
\end{ocamldoccode}



    The extension  {\tt{[\%\%parser ...]}} extends  structure with new  let bindings
    defining grammars. This  applies both for {\tt{let}} and {\tt{let  rec}} the latter
    being  reserved  to recursive  grammars.  We  also provide  an  extension
    {\tt{[\%grammar]}}  for  expression  that  corresponds to  grammars,  i.e.  the
    right-hand side of binding in the {\tt{[\%\%parser]}} extension.


    Here is the BNF for these right-hand-side, with its semantics
    \begin{ocamldoccode}

    grammar ::= rule                                                   itself
           | grammar ; rule                                       Grammar.alt
    rule ::= qitems => expr                            A rule with its action
           | expr < ... < expr                       priority order see below
    qitems ::= ()                                               Grammar.empty
           | non_empty_qitems                                          itself
    non_empty_qitems ::= qitem
           | non_empty_qitems qitems                              Grammar.seq
    qitem ::= item | (lid :: item)          give a name if used in the action
    item ::= {\textquotesingle}...{\textquotesingle}                                  Grammar.term(Lex.char ())
           | "..."                                Grammar.term(Lex.string ())
           | INT                                     Grammar.term(Lex.int ())
           | FLOAT                                 Grammar.term(Lex.float ())
           | RE(exp)        Grammar.term(Lex.regexp (Regexp.from_string exp))
           | exp                                                       itself
    
\end{ocamldoccode}


\begin{itemize}
\item non recursive let bindings correspond to just a name for the grammar.
\item recursive let bindings correspond either to
\item {\tt{declare\_grammar + set\_grammar}} (if no paramater)
\item {\tt{grammar\_familly + setting the grammar}} is a parameter is given.
\end{itemize}

    Anything  which  does not  coresponds  to  this  grammar will  we  keeped
    unchanged in the structure as ocaml code (like the type definition in the
    example  above.   A  mutually  recursive   definition  can  also  mix  te
    definition of grammars (parametric of  not) with the definition of normal
    ocaml values.



\ocamldocvspace{0.5cm}



\subsection{Type}




\label{type:Grammar.grammar}\begin{ocamldoccode}
type {\textquotesingle}a grammar 
\end{ocamldoccode}
\index{grammar@\verb`grammar`}
\begin{ocamldocdescription}
type of a grammar with semantical action of type {\tt{{\textquotesingle}a }}.


\end{ocamldocdescription}




\label{type:Grammar.t}\begin{ocamldoccode}
type {\textquotesingle}a t = {\textquotesingle}a grammar 
\end{ocamldoccode}
\index{t@\verb`t`}
\begin{ocamldocdescription}
An abbreviation


\end{ocamldocdescription}




\subsection{Grammar contructors}




\label{val:Grammar.print-underscoregrammar}\begin{ocamldoccode}
val print_grammar : ?def:bool -> Stdlib.out_channel -> {\textquotesingle}a grammar -> unit
\end{ocamldoccode}
\index{print-underscoregrammar@\verb`print_grammar`}
\begin{ocamldocdescription}
{\tt{print\_grammar ch g}} prints the grammar {\tt{g}} of the given output channel.
    if {\tt{def=false}} (the default is {\tt{true}}) it will print the transformed
    grammar prior to compilation.


\end{ocamldocdescription}




\label{val:Grammar.fail}\begin{ocamldoccode}
val fail : unit -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{fail@\verb`fail`}
\begin{ocamldocdescription}
{\tt{fail ()}} is a grammar that parses nothing (always fails)


\end{ocamldocdescription}




\label{val:Grammar.empty}\begin{ocamldoccode}
val empty : {\textquotesingle}a -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{empty@\verb`empty`}
\begin{ocamldocdescription}
{\tt{empty a}} accepts the empty input and returns {\tt{a}}


\end{ocamldocdescription}




\label{val:Grammar.test}\begin{ocamldoccode}
val test : bool -> unit grammar
\end{ocamldoccode}
\index{test@\verb`test`}
\begin{ocamldocdescription}
{\tt{test b}} is {\tt{if b then empty () else fail ()}}. Very usefull in
    grammar family at the beginning of a rule


\end{ocamldocdescription}




\label{val:Grammar.term}\begin{ocamldoccode}
val term : ?name:string -> {\textquotesingle}a Lex.terminal -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{term@\verb`term`}
\begin{ocamldocdescription}
{\tt{term t}} accepts the terminal {\tt{t}} and returns its semantics.
    See module {\tt{Lex}}


\end{ocamldocdescription}




\label{val:Grammar.appl}\begin{ocamldoccode}
val appl : ?name:string -> {\textquotesingle}a grammar -> ({\textquotesingle}a -> {\textquotesingle}b) -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{appl@\verb`appl`}
\begin{ocamldocdescription}
{\tt{appl g f}} parses with {\tt{g}} and apply {\tt{f}} to the resulting semantics


\end{ocamldocdescription}




\label{val:Grammar.alt}\begin{ocamldoccode}
val alt : {\textquotesingle}a grammar -> {\textquotesingle}a grammar -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{alt@\verb`alt`}
\begin{ocamldocdescription}
{\tt{alt g1 g2}} parses with {\tt{g1}} and if it fails then {\tt{g2}}


\end{ocamldocdescription}




\label{val:Grammar.seq}\begin{ocamldoccode}
val seq : {\textquotesingle}a grammar ->
  {\textquotesingle}b grammar -> ({\textquotesingle}a -> {\textquotesingle}b -> {\textquotesingle}c) -> {\textquotesingle}c grammar
\end{ocamldoccode}
\index{seq@\verb`seq`}
\begin{ocamldocdescription}
{\tt{seq g1 g2 f}} parse with g1 and then with g2 for the rest of the input, uses {\tt{f}}
    to combine both semantics


\end{ocamldocdescription}




\label{val:Grammar.seq1}\begin{ocamldoccode}
val seq1 : {\textquotesingle}a grammar -> {\textquotesingle}b grammar -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{seq1@\verb`seq1`}
\begin{ocamldocdescription}
usefull derivations from {\tt{seq}}


\end{ocamldocdescription}




\label{val:Grammar.seq2}\begin{ocamldoccode}
val seq2 : {\textquotesingle}a grammar -> {\textquotesingle}b grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{seq2@\verb`seq2`}




\label{val:Grammar.seqf}\begin{ocamldoccode}
val seqf : {\textquotesingle}a grammar -> ({\textquotesingle}a -> {\textquotesingle}b) grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{seqf@\verb`seqf`}




\label{val:Grammar.dseq}\begin{ocamldoccode}
val dseq : {\textquotesingle}a grammar ->
  ({\textquotesingle}a -> {\textquotesingle}b grammar) -> ({\textquotesingle}b -> {\textquotesingle}c) -> {\textquotesingle}c grammar
\end{ocamldoccode}
\index{dseq@\verb`dseq`}
\begin{ocamldocdescription}
{\tt{dseq g1 g2 f)}} is a dependant sequence, the grammar {\tt{g2}} used after {\tt{g1}} may
    depend upon the semantics of {\tt{g1}}. This is not very efficient as the grammar
    {\tt{g2}} must be compiled at parsing time. It is a good idea to memoize {\tt{g2}}


\end{ocamldocdescription}




\label{val:Grammar.lpos}\begin{ocamldoccode}
val lpos : (Position.t -> {\textquotesingle}a) grammar -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{lpos@\verb`lpos`}
\begin{ocamldocdescription}
{\tt{lpos g}} is identical to {\tt{g}} but passes the position just before parsing with
    {\tt{g}} to the semantical action of {\tt{g}}


\end{ocamldocdescription}




\label{val:Grammar.rpos}\begin{ocamldoccode}
val rpos : (Position.t -> {\textquotesingle}a) grammar -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{rpos@\verb`rpos`}
\begin{ocamldocdescription}
{\tt{rpos g}} is identical to {\tt{g}} but passes the position just after parsing with
    {\tt{g}} to the semantical action of {\tt{g}}


\end{ocamldocdescription}




\label{val:Grammar.seqf-underscorepos}\begin{ocamldoccode}
val seqf_pos :
  {\textquotesingle}a grammar ->
  (Position.t -> {\textquotesingle}a -> Position.t -> {\textquotesingle}b) grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{seqf-underscorepos@\verb`seqf_pos`}
\begin{ocamldocdescription}
variants of seqf with the position of the first iterm


\end{ocamldocdescription}




\label{val:Grammar.seqf-underscorelpos}\begin{ocamldoccode}
val seqf_lpos :
  {\textquotesingle}a grammar ->
  (Position.t -> {\textquotesingle}a -> {\textquotesingle}b) grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{seqf-underscorelpos@\verb`seqf_lpos`}




\label{val:Grammar.seqf-underscorerpos}\begin{ocamldoccode}
val seqf_rpos :
  {\textquotesingle}a grammar ->
  ({\textquotesingle}a -> Position.t -> {\textquotesingle}b) grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{seqf-underscorerpos@\verb`seqf_rpos`}




\label{val:Grammar.seq2-underscorepos}\begin{ocamldoccode}
val seq2_pos :
  {\textquotesingle}a grammar ->
  (Position.t -> Position.t -> {\textquotesingle}b) grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{seq2-underscorepos@\verb`seq2_pos`}
\begin{ocamldocdescription}
variants of seq2 with the position of the first iterm


\end{ocamldocdescription}




\label{val:Grammar.seq2-underscorelpos}\begin{ocamldoccode}
val seq2_lpos : {\textquotesingle}a grammar ->
  (Position.t -> {\textquotesingle}b) grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{seq2-underscorelpos@\verb`seq2_lpos`}




\label{val:Grammar.seq2-underscorerpos}\begin{ocamldoccode}
val seq2_rpos : {\textquotesingle}a grammar ->
  (Position.t -> {\textquotesingle}b) grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{seq2-underscorerpos@\verb`seq2_rpos`}




\label{val:Grammar.cache}\begin{ocamldoccode}
val cache : {\textquotesingle}a grammar -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{cache@\verb`cache`}
\begin{ocamldocdescription}
{\tt{cache g}} avoid to parse twice the same input with g by memoizing the result
    of the first parsing. Using {\tt{cache}} allows to recover a polynomial complexity


\end{ocamldocdescription}




\label{val:Grammar.layout}\begin{ocamldoccode}
val layout :
  ?old_before:bool ->
  ?new_before:bool ->
  ?new_after:bool ->
  ?old_after:bool -> {\textquotesingle}a grammar -> Lex.blank -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{layout@\verb`layout`}
\begin{ocamldocdescription}
{\tt{layout g b}} changes the blank function to parse the input with the
    grammar {\tt{g}}. The optional parameters allow to control which blanks are used
    at the bounndary. Both can be used in which case the new blanks are used
    second before parsing with {\tt{g}} and first after.


\end{ocamldocdescription}




\subsection{Definition of recursive grammars }




\label{val:Grammar.declare-underscoregrammar}\begin{ocamldoccode}
val declare_grammar : string -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{declare-underscoregrammar@\verb`declare_grammar`}
\begin{ocamldocdescription}
to define recursive grammars, one may declare the grammar first and then
    gives its value.
    {\tt{declare\_grammar name}} creates an undefined grammar with the given name


\end{ocamldocdescription}




\label{val:Grammar.set-underscoregrammar}\begin{ocamldoccode}
val set_grammar : {\textquotesingle}a grammar -> {\textquotesingle}a grammar -> unit
\end{ocamldoccode}
\index{set-underscoregrammar@\verb`set_grammar`}
\begin{ocamldocdescription}
{\tt{set\_grammar g1 g2}} set the value of {\tt{g1}} declared with {\tt{declare\_grammar}}.
    will raise {\tt{Invalid\_argument}} if {\tt{g1}} was not defined using
    {\tt{declare\_grammar}} or if it was already set.


\end{ocamldocdescription}




\label{val:Grammar.fixpoint}\begin{ocamldoccode}
val fixpoint : ?name:string ->
  ({\textquotesingle}a grammar -> {\textquotesingle}a grammar) -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{fixpoint@\verb`fixpoint`}
\begin{ocamldocdescription}
{\tt{fixpoint g}} compute the fixpoint of {\tt{g}}, that is a grammar {\tt{g0}} such that
    {\tt{g0 = g g0}}


\end{ocamldocdescription}




\label{val:Grammar.grammar-underscorefamily}\begin{ocamldoccode}
val grammar_family :
  ?param_to_string:({\textquotesingle}a -> string) ->
  string -> ({\textquotesingle}a -> {\textquotesingle}b grammar) * (({\textquotesingle}a -> {\textquotesingle}b grammar) -> unit)
\end{ocamldoccode}
\index{grammar-underscorefamily@\verb`grammar_family`}
\begin{ocamldocdescription}
{\tt{grammar\_family to\_str name}} returns a pair {\tt{(gs, set\_gs)}}, where {\tt{gs}}
    is a finite family of grammars parametrized by a value of type {\tt{{\textquotesingle}a}}. A name
    {\tt{name}} is to be provided for the family, and an optional function {\tt{to\_str}}
    can be provided to print the parameter and display better error messages.


\end{ocamldocdescription}




\begin{ocamldoccode}

   (* Declare the grammar family *)
   let (gr, set_gr) = grammar_family to_str name in

   ... code using grammars of gr to define mutually recursive grammars ...
   ... the grammars in gr cannot be used in "left position" ...
   ... (same restriction as for declare_grammar ...

   (* Define the grammar family *)
   let _ = set_gr the_grammars

   ... now the new family can be used ...
   
\end{ocamldoccode}




\subsection{Compilation of a grammar and various}




\label{val:Grammar.compile}\begin{ocamldoccode}
val compile : {\textquotesingle}a grammar -> {\textquotesingle}a Combinator.t
\end{ocamldoccode}
\index{compile@\verb`compile`}
\begin{ocamldocdescription}
{\tt{compile g}} produces a combinator that can be used to actually do the parsing
    see the {\tt{Combinator}} module


\end{ocamldocdescription}




\label{val:Grammar.grammar-underscoreinfo}\begin{ocamldoccode}
val grammar_info : {\textquotesingle}a grammar -> bool * Charset.t
\end{ocamldoccode}
\index{grammar-underscoreinfo@\verb`grammar_info`}
\begin{ocamldocdescription}
{\tt{grammar\_info g}} returns {\tt{(b,cs)}} where {\tt{b}} is true is the grammar accepts
    the empty input and where {\tt{cs}} is the characters set accepted at the beginnning
    of the input.


\end{ocamldocdescription}




\label{val:Grammar.grammar-underscorename}\begin{ocamldoccode}
val grammar_name : {\textquotesingle}a grammar -> string
\end{ocamldoccode}
\index{grammar-underscorename@\verb`grammar_name`}
\begin{ocamldocdescription}
gives the grammar name


\end{ocamldocdescription}




\label{val:Grammar.give-underscorename}\begin{ocamldoccode}
val give_name : string -> {\textquotesingle}a grammar -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{give-underscorename@\verb`give_name`}
\begin{ocamldocdescription}
allows to rename a grammar


\end{ocamldocdescription}


\section{Module {\tt{Combinator}} : Combinator library, using continuation}
\label{module:Combinator}\index{Combinator@\verb`Combinator`}



    As usual left recursion is not supported, but the library is intended to
    be used through the {\tt{Grammar}} module that provides elimination of left
    recursion. However, a cache combinatr is supported to overcome the cost
    of backtracking.



\ocamldocvspace{0.5cm}



\subsection{function and type usefull to the end-user}




\label{type:Combinator.combinator}\begin{ocamldoccode}
type {\textquotesingle}a combinator 
\end{ocamldoccode}
\index{combinator@\verb`combinator`}
\begin{ocamldocdescription}
The type of combinator


\end{ocamldocdescription}




\label{type:Combinator.t}\begin{ocamldoccode}
type {\textquotesingle}a t = {\textquotesingle}a combinator 
\end{ocamldoccode}
\index{t@\verb`t`}
\begin{ocamldocdescription}
Abbreviation


\end{ocamldocdescription}




\label{val:Combinator.give-underscoreup}\begin{ocamldoccode}
val give_up : unit -> {\textquotesingle}a
\end{ocamldoccode}
\index{give-underscoreup@\verb`give_up`}
\begin{ocamldocdescription}
{\tt{give\_up ()}} will reject the current parsing rule from the action code


\end{ocamldocdescription}




\label{exception:Combinator.Parse-underscoreerror}\begin{ocamldoccode}
exception Parse_error of Input.buffer * int
\end{ocamldoccode}
\index{Parse-underscoreerror@\verb`Parse_error`}
\begin{ocamldocdescription}
Exception raised by the function below when parsing fails


\end{ocamldocdescription}




\label{val:Combinator.handle-underscoreexception}\begin{ocamldoccode}
val handle_exception : ?error:(unit -> {\textquotesingle}b) -> ({\textquotesingle}a -> {\textquotesingle}b) -> {\textquotesingle}a -> {\textquotesingle}b
\end{ocamldoccode}
\index{handle-underscoreexception@\verb`handle_exception`}
\begin{ocamldocdescription}
{\tt{handle\_exception fn v}} applies the function {\tt{fn}} to {\tt{v}} and handles
    the {\tt{Parse\_error}} exception. In particular, a parse error message is
    presented to the user in  case  of  a  failure, then {\tt{error ()}}
    is called. The default {\tt{error}} is {\tt{fun () -> exit 1}}.


\end{ocamldocdescription}




\label{val:Combinator.parse-underscorebuffer}\begin{ocamldoccode}
val parse_buffer : {\textquotesingle}a t -> Lex.blank -> Input.buffer -> {\textquotesingle}a
\end{ocamldoccode}
\index{parse-underscorebuffer@\verb`parse_buffer`}
\begin{ocamldocdescription}
Parse a whole input buffer. the eof combinator is added at
    the end of the given combinator


\end{ocamldocdescription}




\label{val:Combinator.parse-underscorestring}\begin{ocamldoccode}
val parse_string : {\textquotesingle}a t -> Lex.blank -> string -> {\textquotesingle}a
\end{ocamldoccode}
\index{parse-underscorestring@\verb`parse_string`}
\begin{ocamldocdescription}
Parse a whole string


\end{ocamldocdescription}




\label{val:Combinator.parse-underscorechannel}\begin{ocamldoccode}
val parse_channel : {\textquotesingle}a t -> Lex.blank -> Stdlib.in_channel -> {\textquotesingle}a
\end{ocamldoccode}
\index{parse-underscorechannel@\verb`parse_channel`}
\begin{ocamldocdescription}
Parse a whole input channel


\end{ocamldocdescription}




\label{val:Combinator.partial-underscoreparse-underscorebuffer}\begin{ocamldoccode}
val partial_parse_buffer :
  {\textquotesingle}a t ->
  Lex.blank ->
  ?blank_after:bool -> Input.buffer -> int -> {\textquotesingle}a * Input.buffer * int
\end{ocamldoccode}
\index{partial-underscoreparse-underscorebuffer@\verb`partial_parse_buffer`}
\begin{ocamldocdescription}
Partial parsing. Beware, the returned position is not the maximum position
    that can be reached by the grammar


\end{ocamldocdescription}




\subsection{combinator constructors, normally not needed by the casual user }




\label{val:Combinator.cfail}\begin{ocamldoccode}
val cfail : {\textquotesingle}a t
\end{ocamldoccode}
\index{cfail@\verb`cfail`}
\begin{ocamldocdescription}
Always fails


\end{ocamldocdescription}




\label{val:Combinator.cempty}\begin{ocamldoccode}
val cempty : {\textquotesingle}a -> {\textquotesingle}a t
\end{ocamldoccode}
\index{cempty@\verb`cempty`}
\begin{ocamldocdescription}
Accepting the empty input only


\end{ocamldocdescription}




\label{val:Combinator.cterm}\begin{ocamldoccode}
val cterm : {\textquotesingle}a Lex.fterm -> {\textquotesingle}a t
\end{ocamldoccode}
\index{cterm@\verb`cterm`}
\begin{ocamldocdescription}
Accepts a given terminal


\end{ocamldocdescription}




\label{val:Combinator.cseq}\begin{ocamldoccode}
val cseq : {\textquotesingle}a t -> {\textquotesingle}b t -> ({\textquotesingle}a -> {\textquotesingle}b -> {\textquotesingle}c) -> {\textquotesingle}c t
\end{ocamldoccode}
\index{cseq@\verb`cseq`}
\begin{ocamldocdescription}
Sequence of two combinators, parses with the first and then parses the
    rest of the input with the second combinator. The last function
    is used to compose the semantics returned by the two combinators.


\end{ocamldocdescription}




\label{val:Combinator.cdep-underscoreseq}\begin{ocamldoccode}
val cdep_seq : {\textquotesingle}a t -> ({\textquotesingle}a -> {\textquotesingle}b t) -> ({\textquotesingle}b -> {\textquotesingle}c) -> {\textquotesingle}c t
\end{ocamldoccode}
\index{cdep-underscoreseq@\verb`cdep_seq`}
\begin{ocamldocdescription}
{\tt{sdep\_seq c1 c2 f}} is a dependant sequence, contrary to {\tt{seq c1 c2 f}},
    the combinator used to parse after {\tt{c1}} depends upon the value
    returned by {\tt{c1}}. It s a good idea to memoize the function c2.


\end{ocamldocdescription}




\label{val:Combinator.calt}\begin{ocamldoccode}
val calt : ?cs1:Charset.t ->
  ?cs2:Charset.t -> {\textquotesingle}a t -> {\textquotesingle}a t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{calt@\verb`calt`}
\begin{ocamldocdescription}
Combinator parsing with the first combinator and in case
    of failure with the second from the same position.
    The optionnal charset corresponds to the charaters accepted
    at the beginning of the input for each combinators.
    The charset must be Charset.full if the corresponding combinator
    accept the empty input


\end{ocamldocdescription}




\label{val:Combinator.capp}\begin{ocamldoccode}
val capp : {\textquotesingle}a t -> ({\textquotesingle}a -> {\textquotesingle}b) -> {\textquotesingle}b t
\end{ocamldoccode}
\index{capp@\verb`capp`}
\begin{ocamldocdescription}
Parses with the given combinator and transforms the semantics with
    the given function


\end{ocamldocdescription}




\label{val:Combinator.clpos}\begin{ocamldoccode}
val clpos : (Position.t -> {\textquotesingle}a) t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{clpos@\verb`clpos`}
\begin{ocamldocdescription}
Parses as the given combinator and give the position
    to the left of the parsing input as argument to the action


\end{ocamldocdescription}




\label{val:Combinator.cpush}\begin{ocamldoccode}
val cpush : {\textquotesingle}a t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{cpush@\verb`cpush`}
\begin{ocamldocdescription}
To eliminate left recursion, lpos has to be left factored.
    if lpos is one single combinator, this adds a lot of closures
    in action code. To solve this problem, lpos is splitted in
    two combinators, one that pushes the position to a stack and pops
    after parsing and another that reads the position.


\end{ocamldocdescription}




\label{val:Combinator.cread}\begin{ocamldoccode}
val cread : int -> (Position.t -> {\textquotesingle}a) t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{cread@\verb`cread`}




\label{val:Combinator.crpos}\begin{ocamldoccode}
val crpos : (Position.t -> {\textquotesingle}a) t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{crpos@\verb`crpos`}
\begin{ocamldocdescription}
Same as above with the position to the right


\end{ocamldocdescription}




\label{val:Combinator.clr}\begin{ocamldoccode}
val clr : ?cs2:Charset.t ->
  {\textquotesingle}a t -> ({\textquotesingle}a -> {\textquotesingle}a) t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{clr@\verb`clr`}
\begin{ocamldocdescription}
{\tt{cls c1 c2}} is an optimized version of {\tt{let rec r = seq c1 (seq r c2)}}
    which is illegal as it is left recursive and loops. The optional charset indicates
    the characteres accepted by {\tt{c2}} at the beginning of input.


\end{ocamldocdescription}




\label{val:Combinator.cref}\begin{ocamldoccode}
val cref : {\textquotesingle}a t Stdlib.ref -> {\textquotesingle}a t
\end{ocamldoccode}
\index{cref@\verb`cref`}
\begin{ocamldocdescription}
Access to a reference to a combinator, use by Grammar.compile
    for recursive grammars (not for left recursion


\end{ocamldocdescription}




\label{val:Combinator.clayout}\begin{ocamldoccode}
val clayout :
  ?old_before:bool ->
  ?new_before:bool ->
  ?new_after:bool ->
  ?old_after:bool -> {\textquotesingle}a t -> Lex.blank -> {\textquotesingle}a t
\end{ocamldoccode}
\index{clayout@\verb`clayout`}
\begin{ocamldocdescription}
Change the blank function used to parse with the given combinator.
    we can choose which blank to use at the boundary with the optional
    parameters.


\end{ocamldocdescription}




\label{val:Combinator.ccache}\begin{ocamldoccode}
val ccache : {\textquotesingle}a t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{ccache@\verb`ccache`}
\begin{ocamldocdescription}
Combinator that caches a grammar to avoid exponential behavior.
    parsing with the grammar from each position is memoized to avoid
    parsing twice the same sequence with the same grammar.


\end{ocamldocdescription}


\section{Module {\tt{Lex}} : Lexing: grouping characters before parsing}
\label{module:Lex}\index{Lex@\verb`Lex`}



    It is traditionnal to do parsing in two phases (scanning/parsing).  This
    is not necessary with combinators in general this is still true with
    Pacomb (scannerless). However, this makes the grammar more readable to
    use a lexing phase.


    Moreover, lexing is often done with a longuest match rule that is not
    semantically equivalent to the semantics of context free grammar.


    This modules provide combinator to create terminals that the parser
    will call.


    It also provide function to eliminate "blank" characteres.



\ocamldocvspace{0.5cm}



\label{type:Lex.buf}\begin{ocamldoccode}
type buf = Input.buffer 
\end{ocamldoccode}
\index{buf@\verb`buf`}
\begin{ocamldocdescription}
\subsection{Types and exception}



\end{ocamldocdescription}




\label{type:Lex.blank}\begin{ocamldoccode}
type blank = buf -> int -> buf * int 
\end{ocamldoccode}
\index{blank@\verb`blank`}
\begin{ocamldocdescription}
A blank function is just a function progressing in a buffer


\end{ocamldocdescription}




\label{type:Lex.fterm}\begin{ocamldoccode}
type {\textquotesingle}a fterm = buf -> int -> {\textquotesingle}a * buf * int 
\end{ocamldoccode}
\index{fterm@\verb`fterm`}
\begin{ocamldocdescription}
Type of terminal function, similar to blank, but with a returned value


\end{ocamldocdescription}




\label{type:Lex.terminal}\begin{ocamldoccode}
type {\textquotesingle}a terminal = 
{\char123}  n : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
name


\end{ocamldoccomment}
\begin{ocamldoccode}
  f : {\textquotesingle}a fterm ;
\end{ocamldoccode}
\begin{ocamldoccomment}
the terminal itself


\end{ocamldoccomment}
\begin{ocamldoccode}
  c : Charset.t ;
\end{ocamldoccode}
\begin{ocamldoccomment}
the set of characters accepted
                                       at the beginning of input


\end{ocamldoccomment}
\begin{ocamldoccode}
{\char125}
\end{ocamldoccode}
\index{terminal@\verb`terminal`}
\begin{ocamldocdescription}
The previous type encapsulated in a record


\end{ocamldocdescription}




\label{type:Lex.t}\begin{ocamldoccode}
type {\textquotesingle}a t = {\textquotesingle}a terminal 
\end{ocamldoccode}
\index{t@\verb`t`}
\begin{ocamldocdescription}
Abbreviation


\end{ocamldocdescription}




\label{exception:Lex.NoParse}\begin{ocamldoccode}
exception NoParse
\end{ocamldoccode}
\index{NoParse@\verb`NoParse`}
\begin{ocamldocdescription}
exception when failing,\begin{itemize}
\item can be raised (but not captured) by terminal
\item can be raised (but not captured) by action code in the grammar,
      see {\tt{Combinator.give\_up}}
\item will be raise and captured by {\tt{Combinator.parse\_buffer}} that will give
      the most advanced position
\end{itemize}



\end{ocamldocdescription}




\subsection{Combinators to create terminals}




\label{val:Lex.eof}\begin{ocamldoccode}
val eof : ?name:string -> {\textquotesingle}a -> {\textquotesingle}a t
\end{ocamldoccode}
\index{eof@\verb`eof`}
\begin{ocamldocdescription}
Terminal accepting then end of a buffer only.
    remark: {\tt{eof}} is automatically added at the end of a grammar by
    {\tt{Combinator.parse\_buffer}}.
    {\tt{name}} default is {\tt{"EOF"}}


\end{ocamldocdescription}




\label{val:Lex.char}\begin{ocamldoccode}
val char : ?name:string -> char -> {\textquotesingle}a -> {\textquotesingle}a t
\end{ocamldoccode}
\index{char@\verb`char`}
\begin{ocamldocdescription}
Terminal accepting a given char, remark: {\tt{char {\textquotesingle}{\char92}255{\textquotesingle}}} is equivalent to
    {\tt{eof}}. {\tt{name}} default is the given charater.


\end{ocamldocdescription}




\label{val:Lex.test}\begin{ocamldoccode}
val test : ?name:string -> (char -> bool) -> char t
\end{ocamldoccode}
\index{test@\verb`test`}
\begin{ocamldocdescription}
Accept a character for which the test returns {\tt{true}}. {\tt{name}} default
    to the result of {\tt{Charset.show}}.


\end{ocamldocdescription}




\label{val:Lex.charset}\begin{ocamldoccode}
val charset : ?name:string -> Charset.t -> char t
\end{ocamldoccode}
\index{charset@\verb`charset`}
\begin{ocamldocdescription}
Accept a character in the given charset. {\tt{name}} default as in {\tt{test}}


\end{ocamldocdescription}




\label{val:Lex.not-underscoretest}\begin{ocamldoccode}
val not_test : ?name:string -> (char -> bool) -> {\textquotesingle}a -> {\textquotesingle}a t
\end{ocamldoccode}
\index{not-underscoretest@\verb`not_test`}
\begin{ocamldocdescription}
Reject the input (raises {\tt{Noparse}}) if the first character of the input
    passed the test. Does not read the character if the test fails.
    {\tt{name}} default to {\tt{"{\char94}"}} prepended to the result of {\tt{Charset.show}}.


\end{ocamldocdescription}




\label{val:Lex.not-underscorecharset}\begin{ocamldoccode}
val not_charset : ?name:string -> Charset.t -> {\textquotesingle}a -> {\textquotesingle}a t
\end{ocamldoccode}
\index{not-underscorecharset@\verb`not_charset`}
\begin{ocamldocdescription}
Reject the input (raises {\tt{Noparse}}) if the first character of the input
    is in the charset. Does not read the character if not in the charset.
    {\tt{name}} default as in {\tt{not\_test}}


\end{ocamldocdescription}




\label{val:Lex.seq}\begin{ocamldoccode}
val seq : ?name:string -> {\textquotesingle}a t -> {\textquotesingle}b t -> ({\textquotesingle}a -> {\textquotesingle}b -> {\textquotesingle}c) -> {\textquotesingle}c t
\end{ocamldoccode}
\index{seq@\verb`seq`}
\begin{ocamldocdescription}
Compose two terminals in sequence. {\tt{name}} default is the concatenation
    of the two names.


\end{ocamldocdescription}




\label{val:Lex.seq1}\begin{ocamldoccode}
val seq1 : ?name:string -> {\textquotesingle}a t -> {\textquotesingle}b t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{seq1@\verb`seq1`}




\label{val:Lex.seq2}\begin{ocamldoccode}
val seq2 : ?name:string -> {\textquotesingle}a t -> {\textquotesingle}b t -> {\textquotesingle}b t
\end{ocamldoccode}
\index{seq2@\verb`seq2`}




\label{val:Lex.alt}\begin{ocamldoccode}
val alt : ?name:string -> {\textquotesingle}a t -> {\textquotesingle}a t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{alt@\verb`alt`}
\begin{ocamldocdescription}
{\tt{alt t1 t2}} parses the input with {\tt{t1}} or {\tt{t2}}.
    Contrary to grammars, terminals does not use continuations,
    if {\tt{t1}} succeds, no backtrack will be performed to try {\tt{t2}}.
    For instance,
      {\tt{seq1 (alt (char {\textquotesingle}a{\textquotesingle} ())\
                 (seq1 (char {\textquotesingle}a{\textquotesingle} ()) (char {\textquotesingle}b{\textquotesingle} ())))\
            (char {\textquotesingle}c{\textquotesingle} ())}}
    will reject "abc".
    If both {\tt{t1}} and {\tt{t2}} accept the input, longuest match is selected.
    {\tt{name}} default to {\tt{sprintf "(\%s)|(\%s)" t1.n t2.n}}.


\end{ocamldocdescription}




\label{val:Lex.option}\begin{ocamldoccode}
val option : ?name:string -> {\textquotesingle}a -> {\textquotesingle}a t -> {\textquotesingle}a t
\end{ocamldoccode}
\index{option@\verb`option`}
\begin{ocamldocdescription}
{\tt{option x t}} parses the given terminal 0 or 1 time. {\tt{x}} is returned if 0.
    {\tt{name}} defaults to {\tt{sprintf "(\%s)?" t.n}}.


\end{ocamldocdescription}




\label{val:Lex.appl}\begin{ocamldoccode}
val appl : ?name:string -> ({\textquotesingle}a -> {\textquotesingle}b) -> {\textquotesingle}a t -> {\textquotesingle}b t
\end{ocamldoccode}
\index{appl@\verb`appl`}
\begin{ocamldocdescription}
Applies a function to the result of the given terminal.
    {\tt{name}} defaults to the terminal name.


\end{ocamldocdescription}




\label{val:Lex.star}\begin{ocamldoccode}
val star : ?name:string -> {\textquotesingle}a t -> (unit -> {\textquotesingle}b) -> ({\textquotesingle}b -> {\textquotesingle}a -> {\textquotesingle}b) -> {\textquotesingle}b t
\end{ocamldoccode}
\index{star@\verb`star`}
\begin{ocamldocdescription}
{\tt{star t a f}} Repetition of a given terminal 0,1 or more times.
    The type of function to compose the action allows for {\tt{{\textquotesingle}b = Buffer.t}}
    for efficiency. The returned value is
    {\tt{f ( ... (f(f (a ()) x\_1) x\_2) ...) x\_n}}if {\tt{t}} returns {\tt{x\_1}} $\ldots$ {\tt{x\_n}}.
    The {\tt{name}} defaults to {\tt{sprintf "(\%s)*" t.n}}


\end{ocamldocdescription}




\label{val:Lex.plus}\begin{ocamldoccode}
val plus : ?name:string -> {\textquotesingle}a t -> (unit -> {\textquotesingle}b) -> ({\textquotesingle}b -> {\textquotesingle}a -> {\textquotesingle}b) -> {\textquotesingle}b t
\end{ocamldoccode}
\index{plus@\verb`plus`}
\begin{ocamldocdescription}
Same as above but parses at least once .


\end{ocamldocdescription}




\label{val:Lex.string}\begin{ocamldoccode}
val string : ?name:string -> string -> {\textquotesingle}a -> {\textquotesingle}a t
\end{ocamldoccode}
\index{string@\verb`string`}
\begin{ocamldocdescription}
{\tt{string s}} Accepts only the given string.
    Raises {\tt{Invalid\_argument}} if {\tt{s = ""}}.
    {\tt{name}} defaults to {\tt{sprintf "\%S" s}}.


\end{ocamldocdescription}




\label{val:Lex.int}\begin{ocamldoccode}
val int : ?name:string -> unit -> int t
\end{ocamldoccode}
\index{int@\verb`int`}
\begin{ocamldocdescription}
Parses an integer in base 10. {\tt{"+42"}} is accepted.
    {\tt{name}} defaults to {\tt{"INT"}}


\end{ocamldocdescription}




\label{val:Lex.float}\begin{ocamldoccode}
val float : ?name:string -> unit -> float t
\end{ocamldoccode}
\index{float@\verb`float`}
\begin{ocamldocdescription}
Parses a float in base 10. {\tt{".1"}} is not accepted {\tt{"0.1"}} is.
    {\tt{name}} defaults to {\tt{"FLOAT"}}


\end{ocamldocdescription}




\label{val:Lex.keyword}\begin{ocamldoccode}
val keyword : ?name:string -> string -> (char -> bool) -> {\textquotesingle}a -> {\textquotesingle}a t
\end{ocamldoccode}
\index{keyword@\verb`keyword`}
\begin{ocamldocdescription}
{\tt{keyword {\char126}name k cs x =\
     seq {\char126}name (string k ()) (test f ()) (fun \_ \_ -> x)}}
    usefull to accept a keyword only when not followed by an alpha-numeric char


\end{ocamldocdescription}




\label{val:Lex.regexp}\begin{ocamldoccode}
val regexp : ?name:string -> Regexp.t -> string t
\end{ocamldoccode}
\index{regexp@\verb`regexp`}
\begin{ocamldocdescription}
create a terminal from a regexp. Returns the whole matched string


\end{ocamldocdescription}




\label{val:Lex.regexp-underscoregrps}\begin{ocamldoccode}
val regexp_grps : ?name:string -> Regexp.t -> string list t
\end{ocamldoccode}
\index{regexp-underscoregrps@\verb`regexp_grps`}
\begin{ocamldocdescription}
create a terminal from a regexp. Returns the groups list, last to finish
    to be parsed is first in the result


\end{ocamldocdescription}




\subsection{Functions managing blanks}




\label{val:Lex.noblank}\begin{ocamldoccode}
val noblank : blank
\end{ocamldoccode}
\index{noblank@\verb`noblank`}
\begin{ocamldocdescription}
Use when you have no blank chars


\end{ocamldocdescription}




\label{val:Lex.blank-underscorecharset}\begin{ocamldoccode}
val blank_charset : Charset.t -> blank
\end{ocamldoccode}
\index{blank-underscorecharset@\verb`blank_charset`}
\begin{ocamldocdescription}
Blank from a charset


\end{ocamldocdescription}




\label{val:Lex.blank-underscoreterminal}\begin{ocamldoccode}
val blank_terminal : {\textquotesingle}a t -> blank
\end{ocamldoccode}
\index{blank-underscoreterminal@\verb`blank_terminal`}
\begin{ocamldocdescription}
Blank from a terminal


\end{ocamldocdescription}




\label{val:Lex.accept-underscoreempty}\begin{ocamldoccode}
val accept_empty : {\textquotesingle}a t -> bool
\end{ocamldoccode}
\index{accept-underscoreempty@\verb`accept_empty`}
\begin{ocamldocdescription}
Test wether a terminal accept the empty string. Such a terminal
   are illegal in a grammar, but may be used in combinator below to create
   terminals


\end{ocamldocdescription}


\section{Module {\tt{Regexp}} : A small module for efficient regular expressions.}
\label{module:Regexp}\index{Regexp@\verb`Regexp`}




\ocamldocvspace{0.5cm}



\label{type:Regexp.regexp}\begin{ocamldoccode}
type regexp =
  | Chr of char
  | Set of Charset.t
  | Seq of regexp list
  | Alt of regexp list
  | Opt of regexp
  | Str of regexp
  | Pls of regexp
  | Sav of regexp
\end{ocamldoccode}
\index{regexp@\verb`regexp`}
\begin{ocamldocdescription}
Type of a regular expression.


\end{ocamldocdescription}




\label{type:Regexp.t}\begin{ocamldoccode}
type t = regexp 
\end{ocamldoccode}
\index{t@\verb`t`}




\label{exception:Regexp.Regexp-underscoreerror}\begin{ocamldoccode}
exception Regexp_error of Input.buffer * int
\end{ocamldoccode}
\index{Regexp-underscoreerror@\verb`Regexp_error`}
\begin{ocamldocdescription}
Exception that is raised when a regexp cannot be read.


\end{ocamldocdescription}




\label{val:Regexp.print}\begin{ocamldoccode}
val print : Stdlib.out_channel -> regexp -> unit
\end{ocamldoccode}
\index{print@\verb`print`}




\label{val:Regexp.accept-underscoreempty}\begin{ocamldoccode}
val accept_empty : regexp -> bool
\end{ocamldoccode}
\index{accept-underscoreempty@\verb`accept_empty`}




\label{val:Regexp.accepted-underscorefirst-underscorechars}\begin{ocamldoccode}
val accepted_first_chars : regexp -> Charset.t
\end{ocamldoccode}
\index{accepted-underscorefirst-underscorechars@\verb`accepted_first_chars`}




\label{val:Regexp.from-underscorestring}\begin{ocamldoccode}
val from_string : string -> regexp
\end{ocamldoccode}
\index{from-underscorestring@\verb`from_string`}




\label{val:Regexp.read}\begin{ocamldoccode}
val read : regexp -> Input.buffer -> int -> string list * Input.buffer * int
\end{ocamldoccode}
\index{read@\verb`read`}
\begin{ocamldocdescription}
{\tt{read re buf pos}} attempts to parse using the buffer {\tt{buf}} at
    position {\tt{pos}} using the regular expression {\tt{re}}. The return value is
    a triple of the parsed string, the buffer after parsing and the
    position after parsing. The exception {\tt{Regexp\_error(err\_buf, err\_pos}}
    is raised in case of failure at the given position.


\end{ocamldocdescription}


\section{Module {\tt{Input}} : A module providing efficient input buffers with preprocessing.}
\label{module:Input}\index{Input@\verb`Input`}




\ocamldocvspace{0.5cm}



\subsection{Type}




\label{type:Input.buffer}\begin{ocamldoccode}
type buffer 
\end{ocamldoccode}
\index{buffer@\verb`buffer`}
\begin{ocamldocdescription}
The abstract type for an input buffer.


\end{ocamldocdescription}




\subsection{Reading from a buffer}




\label{val:Input.read}\begin{ocamldoccode}
val read : buffer -> int -> char * buffer * int
\end{ocamldoccode}
\index{read@\verb`read`}
\begin{ocamldocdescription}
{\tt{read buf pos}} returns the character at position {\tt{pos}} in the buffer
    {\tt{buf}}, together with the new buffer and position.


\end{ocamldocdescription}




\label{val:Input.sub}\begin{ocamldoccode}
val sub : buffer -> int -> int -> string
\end{ocamldoccode}
\index{sub@\verb`sub`}
\begin{ocamldocdescription}
{\tt{sub b i len}} returns {\tt{len}} characters from position {\tt{pos}}. If the
    end of buffer is reached, the string is filed with eof '{\char92}255'


\end{ocamldocdescription}




\label{val:Input.get}\begin{ocamldoccode}
val get : buffer -> int -> char
\end{ocamldoccode}
\index{get@\verb`get`}
\begin{ocamldocdescription}
{\tt{get buf pos}} returns the character at position {\tt{pos}} in the  buffer
    {\tt{buf}}.


\end{ocamldocdescription}




\subsection{Creating a buffer}




\label{val:Input.from-underscorefile}\begin{ocamldoccode}
val from_file : string -> buffer
\end{ocamldoccode}
\index{from-underscorefile@\verb`from_file`}
\begin{ocamldocdescription}
{\tt{from\_file fn}} returns a buffer constructed using the file {\tt{fn}}.


\end{ocamldocdescription}




\label{val:Input.from-underscorechannel}\begin{ocamldoccode}
val from_channel : ?filename:string -> Stdlib.in_channel -> buffer
\end{ocamldoccode}
\index{from-underscorechannel@\verb`from_channel`}
\begin{ocamldocdescription}
{\tt{from\_channel {\char126}filename ch}} returns a buffer constructed  using  the
    channel {\tt{ch}}. The optional {\tt{filename}} is only used as a reference to
    the channel in error messages.


\end{ocamldocdescription}




\label{val:Input.from-underscorestring}\begin{ocamldoccode}
val from_string : ?filename:string -> string -> buffer
\end{ocamldoccode}
\index{from-underscorestring@\verb`from_string`}
\begin{ocamldocdescription}
{\tt{from\_string {\char126}filename str}} returns a buffer constructed  using  the
    string {\tt{str}}. The optional {\tt{filename}} is only used as a reference to
    the channel in error messages.


\end{ocamldocdescription}




\label{val:Input.from-underscorefun}\begin{ocamldoccode}
val from_fun : ({\textquotesingle}a -> unit) -> string -> ({\textquotesingle}a -> string) -> {\textquotesingle}a -> buffer
\end{ocamldoccode}
\index{from-underscorefun@\verb`from_fun`}
\begin{ocamldocdescription}
{\tt{from\_fun finalise name get data}} returns a buffer constructed  from
    the object {\tt{data}} using the {\tt{get}} function. The get function is used
    to obtain one line of input from {\tt{data}}. The {\tt{finalise}} function  is
    applied to {\tt{data}} when the end of file is reached. The {\tt{name}} string
    is used to reference the origin of the data in error messages.


\end{ocamldocdescription}




\label{exception:Input.Preprocessor-underscoreerror}\begin{ocamldoccode}
exception Preprocessor_error of string * string
\end{ocamldoccode}
\index{Preprocessor-underscoreerror@\verb`Preprocessor_error`}
\begin{ocamldocdescription}
Exception that can be raised by a preprocessor in case of error. The
    first string references the name of the buffer (e.g. the name of the
    corresponding file) and the second string contains the message.


\end{ocamldocdescription}




\label{val:Input.pp-underscoreerror}\begin{ocamldoccode}
val pp_error : string -> string -> {\textquotesingle}a
\end{ocamldoccode}
\index{pp-underscoreerror@\verb`pp_error`}
\begin{ocamldocdescription}
{\tt{pp\_error name msg}} raises {\tt{Preprocessor\_error(name,msg)}}.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module type }}{\tt{Preprocessor}}{\tt{ = }}\end{ocamldoccode}
\label{moduletype:Input.Preprocessor}\index{Preprocessor@\verb`Preprocessor`}

\begin{ocamldocsigend}


\label{type:Input.Preprocessor.state}\begin{ocamldoccode}
type state 
\end{ocamldoccode}
\index{state@\verb`state`}
\begin{ocamldocdescription}
Type for the internal state of the preprocessor.


\end{ocamldocdescription}


\label{val:Input.Preprocessor.initial-underscorestate}\begin{ocamldoccode}
val initial_state : state
\end{ocamldoccode}
\index{initial-underscorestate@\verb`initial_state`}
\begin{ocamldocdescription}
Initial state of the preprocessor.


\end{ocamldocdescription}


\label{val:Input.Preprocessor.update}\begin{ocamldoccode}
val update :
  state ->
  string -> int -> string -> state * string * int * bool
\end{ocamldoccode}
\index{update@\verb`update`}
\begin{ocamldocdescription}
{\tt{update st name lnum line}} takes as input the state {\tt{st}} of  the
        preprocessor, the file name {\tt{name}}, the number of the next input
        line {\tt{lnum}} and the next input line {\tt{line}} itself. It returns  a
        tuple of the new state, the new file name, the new line  number,
        and a boolean. The new file name and line number can be used  to
        implement line number directives. The boolean is {\tt{true}}  if  the
        line should be part of the input (i.e.  it  is  not  a  specific
        preprocessor line) and {\tt{false}} if  it  should  be  ignored.  The
        function may raise {\tt{Preprocessor\_error}} in case of error.


\end{ocamldocdescription}


\label{val:Input.Preprocessor.check-underscorefinal}\begin{ocamldoccode}
val check_final : state -> string -> unit
\end{ocamldoccode}
\index{check-underscorefinal@\verb`check_final`}
\begin{ocamldocdescription}
{\tt{check\_final st name}} check that {\tt{st}} indeed is a correct  state
        of the preprocessor for the end of input of file {\tt{name}}.  If  it
        is not the  case, then  the  exception  {\tt{Preprocessor\_error}}  is
        raised.


\end{ocamldocdescription}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Specification of a preprocessor.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{WithPP}}{\tt{ : }}\end{ocamldoccode}
\label{module:Input.WithPP}\index{WithPP@\verb`WithPP`}

{\tt{functor (}}{\tt{PP}}{\tt{ : }}{\tt{Preprocessor}}{\tt{) -> }}\begin{ocamldocsigend}


\label{val:Input.WithPP.from-underscorefun}\begin{ocamldoccode}
val from_fun : ({\textquotesingle}a -> unit) -> string -> ({\textquotesingle}a -> string) -> {\textquotesingle}a -> Input.buffer
\end{ocamldoccode}
\index{from-underscorefun@\verb`from_fun`}
\begin{ocamldocdescription}
Same as {\tt{Input.from\_fun}} but uses the preprocessor.


\end{ocamldocdescription}


\label{val:Input.WithPP.from-underscorechannel}\begin{ocamldoccode}
val from_channel : ?filename:string -> Stdlib.in_channel -> Input.buffer
\end{ocamldoccode}
\index{from-underscorechannel@\verb`from_channel`}
\begin{ocamldocdescription}
Same as {\tt{Input.from\_channel}} but uses the preprocessor.


\end{ocamldocdescription}


\label{val:Input.WithPP.from-underscorefile}\begin{ocamldoccode}
val from_file : string -> Input.buffer
\end{ocamldoccode}
\index{from-underscorefile@\verb`from_file`}
\begin{ocamldocdescription}
Same as {\tt{Input.from\_file}} but uses the preprocessor.


\end{ocamldocdescription}


\label{val:Input.WithPP.from-underscorestring}\begin{ocamldoccode}
val from_string : ?filename:string -> string -> Input.buffer
\end{ocamldoccode}
\index{from-underscorestring@\verb`from_string`}
\begin{ocamldocdescription}
Same as {\tt{Input.from\_string}} but uses the preprocessor.


\end{ocamldocdescription}
\end{ocamldocsigend}




\begin{ocamldocdescription}
Functor for building buffers with a preprocessor.


\end{ocamldocdescription}




\subsection{Buffer manipulation functions}




\label{val:Input.is-underscoreempty}\begin{ocamldoccode}
val is_empty : buffer -> int -> bool
\end{ocamldoccode}
\index{is-underscoreempty@\verb`is_empty`}
\begin{ocamldocdescription}
{\tt{is\_empty buf}} test whether the buffer {\tt{buf}} is empty.


\end{ocamldocdescription}




\label{val:Input.line-underscorenum}\begin{ocamldoccode}
val line_num : buffer -> int
\end{ocamldoccode}
\index{line-underscorenum@\verb`line_num`}
\begin{ocamldocdescription}
{\tt{line\_num buf}} returns the current line number of {\tt{buf}}.


\end{ocamldocdescription}




\label{val:Input.line-underscoreoffset}\begin{ocamldoccode}
val line_offset : buffer -> int
\end{ocamldoccode}
\index{line-underscoreoffset@\verb`line_offset`}
\begin{ocamldocdescription}
{\tt{line\_beginning buf}} returns the offset of the current line  in  the
    buffer {\tt{buf}}.


\end{ocamldocdescription}




\label{val:Input.line}\begin{ocamldoccode}
val line : buffer -> string
\end{ocamldoccode}
\index{line@\verb`line`}
\begin{ocamldocdescription}
{\tt{line buf}} returns the current line in the buffer {\tt{buf}}.


\end{ocamldocdescription}




\label{val:Input.line-underscorelength}\begin{ocamldoccode}
val line_length : buffer -> int
\end{ocamldoccode}
\index{line-underscorelength@\verb`line_length`}
\begin{ocamldocdescription}
{\tt{line\_length buf}} returns the length of  the  current  line  in  the
    buffer {\tt{buf}}.


\end{ocamldocdescription}




\label{val:Input.utf8-underscorecol-underscorenum}\begin{ocamldoccode}
val utf8_col_num : buffer -> int -> int
\end{ocamldoccode}
\index{utf8-underscorecol-underscorenum@\verb`utf8_col_num`}
\begin{ocamldocdescription}
{\tt{utf8\_col\_num buf pos}} returns the utf8 column number  corresponding
    to the position {\tt{pos}} in {\tt{buf}}.


\end{ocamldocdescription}




\label{val:Input.normalize}\begin{ocamldoccode}
val normalize : buffer -> int -> buffer * int
\end{ocamldoccode}
\index{normalize@\verb`normalize`}
\begin{ocamldocdescription}
{\tt{normalize buf pos}} ensures that {\tt{pos}} is less than  the  length  of
    the current line in {\tt{str}}.


\end{ocamldocdescription}




\label{val:Input.filename}\begin{ocamldoccode}
val filename : buffer -> string
\end{ocamldoccode}
\index{filename@\verb`filename`}
\begin{ocamldocdescription}
{\tt{filename buf}} returns the file name associated to the {\tt{buf}}.


\end{ocamldocdescription}




\label{val:Input.buffer-underscoreuid}\begin{ocamldoccode}
val buffer_uid : buffer -> int
\end{ocamldoccode}
\index{buffer-underscoreuid@\verb`buffer_uid`}
\begin{ocamldocdescription}
{\tt{buffer\_uid buf}} returns a unique identifier for {\tt{buf}}.


\end{ocamldocdescription}




\label{val:Input.buffer-underscoreequal}\begin{ocamldoccode}
val buffer_equal : buffer -> buffer -> bool
\end{ocamldoccode}
\index{buffer-underscoreequal@\verb`buffer_equal`}
\begin{ocamldocdescription}
{\tt{buffer\_eq b1 b2}} tests the equality of {\tt{b1}} and {\tt{b2}}.


\end{ocamldocdescription}




\label{val:Input.buffer-underscorecompare}\begin{ocamldoccode}
val buffer_compare : buffer -> buffer -> int
\end{ocamldoccode}
\index{buffer-underscorecompare@\verb`buffer_compare`}
\begin{ocamldocdescription}
{\tt{buffer\_compare b1 b2}} compares {\tt{b1}} and {\tt{b2}}.


\end{ocamldocdescription}




\label{val:Input.buffer-underscorebefore}\begin{ocamldoccode}
val buffer_before : buffer -> int -> buffer -> int -> bool
\end{ocamldoccode}
\index{buffer-underscorebefore@\verb`buffer_before`}
\begin{ocamldocdescription}
{\tt{leq\_bug b1 i1 b2 i2}} returns true if the position {\tt{b1, i1}} is before
    {\tt{b2, i2}}. Gives meaningless result if {\tt{b1}} and {\tt{b2}} do not refer to the
    same file.


\end{ocamldocdescription}




\begin{ocamldoccode}
{\tt{module }}{\tt{Tbl}}{\tt{ : }}\end{ocamldoccode}
\label{module:Input.Tbl}\index{Tbl@\verb`Tbl`}

\begin{ocamldocsigend}


\label{type:Input.Tbl.t}\begin{ocamldoccode}
type {\textquotesingle}a t 
\end{ocamldoccode}
\index{t@\verb`t`}


\label{val:Input.Tbl.create}\begin{ocamldoccode}
val create : unit -> {\textquotesingle}a t
\end{ocamldoccode}
\index{create@\verb`create`}


\label{val:Input.Tbl.add}\begin{ocamldoccode}
val add : {\textquotesingle}a t -> Input.buffer -> int -> {\textquotesingle}a -> unit
\end{ocamldoccode}
\index{add@\verb`add`}


\label{val:Input.Tbl.find}\begin{ocamldoccode}
val find : {\textquotesingle}a t -> Input.buffer -> int -> {\textquotesingle}a
\end{ocamldoccode}
\index{find@\verb`find`}


\label{val:Input.Tbl.clear}\begin{ocamldoccode}
val clear : {\textquotesingle}a t -> unit
\end{ocamldoccode}
\index{clear@\verb`clear`}


\label{val:Input.Tbl.iter}\begin{ocamldoccode}
val iter : {\textquotesingle}a t -> ({\textquotesingle}a -> unit) -> unit
\end{ocamldoccode}
\index{iter@\verb`iter`}
\end{ocamldocsigend}


\begin{ocamldocdescription}
Table to associate value to positions in input buffers


\end{ocamldocdescription}


\section{Module {\tt{Position}} : Functions managing positions}
\label{module:Position}\index{Position@\verb`Position`}




\ocamldocvspace{0.5cm}



\label{type:Position.pos}\begin{ocamldoccode}
type pos = 
{\char123}  name : string ;
\end{ocamldoccode}
\begin{ocamldoccomment}
file's name


\end{ocamldoccomment}
\begin{ocamldoccode}
  line : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
line number


\end{ocamldoccomment}
\begin{ocamldoccode}
  col : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
column number


\end{ocamldoccomment}
\begin{ocamldoccode}
  utf8_col : int ;
\end{ocamldoccode}
\begin{ocamldoccomment}
column number with unicode


\end{ocamldoccomment}
\begin{ocamldoccode}
  phantom : bool ;
\end{ocamldoccode}
\begin{ocamldoccomment}
is the postion a "phantom", i.e. not really
                                in the file


\end{ocamldoccomment}
\begin{ocamldoccode}
{\char125}
\end{ocamldoccode}
\index{pos@\verb`pos`}
\begin{ocamldocdescription}
Type to represent position


\end{ocamldocdescription}




\label{type:Position.t}\begin{ocamldoccode}
type t = pos 
\end{ocamldoccode}
\index{t@\verb`t`}
\begin{ocamldocdescription}
Abbreviation


\end{ocamldocdescription}




\label{val:Position.phantom}\begin{ocamldoccode}
val phantom : pos
\end{ocamldoccode}
\index{phantom@\verb`phantom`}
\begin{ocamldocdescription}
a phantom position, used for grammar accepting the empty input


\end{ocamldocdescription}




\label{val:Position.max-underscorepos}\begin{ocamldoccode}
val max_pos : pos -> pos -> pos
\end{ocamldoccode}
\index{max-underscorepos@\verb`max_pos`}
\begin{ocamldocdescription}
the max of to position (further in the file


\end{ocamldocdescription}




\label{val:Position.compute-underscoreutf8-underscorecol}\begin{ocamldoccode}
val compute_utf8_col : bool Stdlib.ref
\end{ocamldoccode}
\index{compute-underscoreutf8-underscorecol@\verb`compute_utf8_col`}
\begin{ocamldocdescription}
if false (the default) {\tt{utf8\_col}} field is set to {\tt{-1}} by {\tt{get\_pos}}


\end{ocamldocdescription}




\label{val:Position.get-underscorepos}\begin{ocamldoccode}
val get_pos : Input.buffer -> int -> pos
\end{ocamldoccode}
\index{get-underscorepos@\verb`get_pos`}
\begin{ocamldocdescription}
Get a position from an input buffer and a column number


\end{ocamldocdescription}


\section{Module {\tt{Earley}} : Earley compatible interface (UNFINISHED) }
\label{module:Earley}\index{Earley@\verb`Earley`}




\ocamldocvspace{0.5cm}



Earley is a parser combinator library implemented using  the  Earley
    algorithm. This modules is an UNFINISHED WORK to provide an Earley
    compatible interface to Pacomb



\subsection{Types and exceptions}




\label{type:Earley.grammar}\begin{ocamldoccode}
type {\textquotesingle}a grammar 
\end{ocamldoccode}
\index{grammar@\verb`grammar`}
\begin{ocamldocdescription}
Type of a parser (or grammar) producing a value of type {\tt{{\textquotesingle}a}}.


\end{ocamldocdescription}




\label{type:Earley.blank}\begin{ocamldoccode}
type blank = Input.buffer -> int -> Input.buffer * int 
\end{ocamldoccode}
\index{blank@\verb`blank`}
\begin{ocamldocdescription}
As {\tt{Earley}} does scannerless parsing, a notion of  {\tt{blank}}  function
    is used to discard meaningless parts of the input (e.g. comments  or
    spaces). A {\tt{blank}} function takes as input a {\tt{buffer}} and a position
    (represented as an {\tt{int}}) and returns a couple of a {\tt{buffer}}  and  a
    position corresponding to the next meaningful character.


    WARNING: a blank function must return a normalized pair (b,p),
    which means 0 $\leq$ p $<$ Input.line\_num b. You can use Input.normalize
    to ensure this.


\end{ocamldocdescription}




\label{exception:Earley.Parse-underscoreerror}\begin{ocamldoccode}
exception Parse_error of Input.buffer * int
\end{ocamldoccode}
\index{Parse-underscoreerror@\verb`Parse_error`}
\begin{ocamldocdescription}
The exception {\tt{Parse\_error(buf,pos,msgs)}} is raised whenever parsing
    fails. It contains the position {\tt{pos}} (and the corresponding  buffer
    {\tt{buf}}) of the furthest reached position in the input.


\end{ocamldocdescription}




\label{val:Earley.give-underscoreup}\begin{ocamldoccode}
val give_up : unit -> {\textquotesingle}a
\end{ocamldoccode}
\index{give-underscoreup@\verb`give_up`}
\begin{ocamldocdescription}
{\tt{give\_up ()}} can be called by the user to force the parser to reject
    a possible parsing rule.


\end{ocamldocdescription}




\label{val:Earley.handle-underscoreexception}\begin{ocamldoccode}
val handle_exception : ?error:(unit -> {\textquotesingle}b) -> ({\textquotesingle}a -> {\textquotesingle}b) -> {\textquotesingle}a -> {\textquotesingle}b
\end{ocamldoccode}
\index{handle-underscoreexception@\verb`handle_exception`}
\begin{ocamldocdescription}
{\tt{handle\_exception fn v}} applies the function {\tt{fn}} to {\tt{v}} and handles
    the {\tt{Parse\_error}} exception. In particular, a parse error message is
    presented to the user in  case  of  a  failure, then {\tt{error ()}}
    is called. The default {\tt{error}} is {\tt{fun () -> exit 1}}.


\end{ocamldocdescription}




\subsection{Atomic parsers}




\label{val:Earley.char}\begin{ocamldoccode}
val char : ?name:string -> char -> {\textquotesingle}a -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{char@\verb`char`}
\begin{ocamldocdescription}
{\tt{char {\char126}name c v}} is a grammar that accepts only the  character  {\tt{c}},
    and returns {\tt{v}} as a semantic value. An optional {\tt{name}} can be given
    to the grammar for reference in error messages.


\end{ocamldocdescription}




\label{val:Earley.string}\begin{ocamldoccode}
val string : ?name:string -> string -> {\textquotesingle}a -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{string@\verb`string`}
\begin{ocamldocdescription}
{\tt{string s v}} is a grammar that accepts only the  string  {\tt{str}},  and
    returns {\tt{v}} as a semantic value. An optional {\tt{name}} can be given  to
    the grammar for reference in error messages.


\end{ocamldocdescription}




\label{val:Earley.keyword}\begin{ocamldoccode}
val keyword : ?name:string -> string -> (char -> bool) -> {\textquotesingle}a -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{keyword@\verb`keyword`}
\begin{ocamldocdescription}
{\tt{keyword s forbidden v}} is simalar to string, but the parsing fails
    if {\tt{forbidden c}} returns {\tt{true}} when {\tt{c}} is the next available
    character.


\end{ocamldocdescription}




\label{val:Earley.eof}\begin{ocamldoccode}
val eof : {\textquotesingle}a -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{eof@\verb`eof`}
\begin{ocamldocdescription}
{\tt{eof v}} is a grammar that only accepts the end of file  and  returns
    {\tt{v}} as a semantic value. Note that the end of file can be parsed one
    or more times (i.e. the input ends with infinitely many end of  file
    symbols.


\end{ocamldocdescription}




\label{val:Earley.any}\begin{ocamldoccode}
val any : char grammar
\end{ocamldoccode}
\index{any@\verb`any`}
\begin{ocamldocdescription}
{\tt{any}} is a grammar that accepts a single character (but fails on the
    end of file) and returns its value.


\end{ocamldocdescription}




\label{val:Earley.in-underscorecharset}\begin{ocamldoccode}
val in_charset : ?name:string -> Charset.charset -> char grammar
\end{ocamldoccode}
\index{in-underscorecharset@\verb`in_charset`}
\begin{ocamldocdescription}
{\tt{in\_charset cs}} is a grammar that parses any character of  the  {\tt{cs}}
    charset, and returns its value. An optional {\tt{name}} can be  given  to
    the grammar for reference in error messages.


\end{ocamldocdescription}




{\tt{not\_in\_charset cs}} is similar to  {\tt{in\_charset cs}}  but  it  accepts
    the characters that are not in {\tt{cs}}.



{\tt{blank\_not\_in\_charset cs}} is the same as {\tt{not\_in\_charset}} but
    testing with blank\_test.



\label{val:Earley.empty}\begin{ocamldoccode}
val empty : {\textquotesingle}a -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{empty@\verb`empty`}
\begin{ocamldocdescription}
{\tt{empty v}} is a grammar that does not parse anything and returns  {\tt{v}}
    as a semantic value. Note that this grammar never fails.


\end{ocamldocdescription}




\label{type:Earley.fpos}\begin{ocamldoccode}
type {\textquotesingle}a fpos = Input.buffer -> int -> Input.buffer -> int -> {\textquotesingle}a 
\end{ocamldoccode}
\index{fpos@\verb`fpos`}
\begin{ocamldocdescription}
type for a function waiting for the start and end positions
    (i.e. buffer and index) of an item, in general resulting from parsing


\end{ocamldocdescription}




{\tt{empty\_pos v}} is similar to the above except that the action
    wait for the position of a complete sequence build using
     {\tt{fsequence}} of {\tt{sequence}}.


     For instance, {\tt{sequence\_position g1 g2 f}} below can be defined
     as {\tt{fsequence g1 (fsequence g2 (empty\_pos f{\textquotesingle}))}}.
     where {\tt{f{\textquotesingle} = fun b p b{\textquotesingle} p{\textquotesingle} a2 a1 = f b p b{\textquotesingle} p{\textquotesingle} a1 a2}} to give
     the result of g1 and g2 in the expected order.



\label{val:Earley.fail}\begin{ocamldoccode}
val fail : unit -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{fail@\verb`fail`}
\begin{ocamldocdescription}
{\tt{fail ()}} is a grammar that always fail, whatever the input.


\end{ocamldocdescription}




{\tt{black\_box fn cs accept\_empty name}} is a grammar that uses the
    function {\tt{fn}} to parses the input buffer. {\tt{fn buf pos}} should
    start parsing {\tt{buf}} at position {\tt{pos}}, and return a couple
    containing the new buffer and position of the first unread
    character. The character set {\tt{cs}} must contain at least the
    characters that are accepted as first character by {\tt{fn}}, and no
    less. The boolean {\tt{accept\_empty}} must be true if the function
    accept the empty string. The {\tt{name}} argument is used for reference
    in error messages. Note that the functon {\tt{fn}} should use {\tt{give\_up ()}}
    in case of a parse error.


    WARNING: fn must return a triple (x,b,p) when (b,p) is normalized,
    which means 0 $\leq$ p $<$ Input.line\_num b. You can use Input.normalize to
    ensure this.



{\tt{debug msg}} is a dummy grammar that always succeeds and prints {\tt{msg}}
    on {\tt{stderr}} when used. It is useful for debugging.



\label{val:Earley.regexp}\begin{ocamldoccode}
val regexp : ?name:string -> string -> string array grammar
\end{ocamldoccode}
\index{regexp@\verb`regexp`}
\begin{ocamldocdescription}
{\tt{regexp ?name re}} is a grammar that uses the regexp {\tt{re}} to parse
    the input buffer. The value returnes is the array of the contents
    of the groups.


\end{ocamldocdescription}




\subsection{Blanks management}




\label{val:Earley.no-underscoreblank}\begin{ocamldoccode}
val no_blank : blank
\end{ocamldoccode}
\index{no-underscoreblank@\verb`no_blank`}
\begin{ocamldocdescription}
{\tt{no\_blank}} is a {\tt{blank}} function that does not discard any character
    of the input buffer.


\end{ocamldocdescription}




{\tt{blank\_regexp re}} builds a blank from the regexp {\tt{re}}.



{\tt{blank\_grammar gr bl}} produces a {\tt{blank}} function using the  grammar
    {\tt{gr}} and the {\tt{blank}} function {\tt{bl}}. It parses as much of  the  input
    as possible using the grammar {\tt{gr}} with the {\tt{blank}}  function  {\tt{bl}},
    and returns the reached position.



{\tt{change\_layout {\char126}old\_blank\_before  {\char126}new\_blank\_after  gr bl}}  replaces
    the current  {\tt{blank}}  function with {\tt{bl}},  while  parsing  using the
    grammar {\tt{gr}}.  The optional  parameter {\tt{old\_blank\_before}} ({\tt{true}} by
    default)  forces the application of the old blank  function,  before
    starting to parse with  {\tt{gr}}.  Note  that the new blank  function is
    always called before the first terminal of {\tt{gr}}. Similarly, the opt-
    -ional parameter {\tt{new\_blank\_after}} ({\tt{true}} by default) forces a call
    to the new blank function after the end of the parsing of {\tt{gr}}. Note
    that the old blank function is always called after the last terminal.



{\tt{change\_layout {\char126}oba gr bl}} same as abobe but with no blank.  It
    keeps the first char prediction and is therefore more efficient



\subsection{Support for recursive grammars}




\label{val:Earley.declare-underscoregrammar}\begin{ocamldoccode}
val declare_grammar : string -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{declare-underscoregrammar@\verb`declare_grammar`}
\begin{ocamldocdescription}
{\tt{declare\_grammar name}} returns a new grammar that can be used in the
    definition of other grammars, but that cannot be run on input before
    it has been initialized with {\tt{set\_grammar}}. The {\tt{name}}  argument  is
    used for reference to the grammar in error messages.


\end{ocamldocdescription}




\label{val:Earley.set-underscoregrammar}\begin{ocamldoccode}
val set_grammar : {\textquotesingle}a grammar -> {\textquotesingle}a grammar -> unit
\end{ocamldoccode}
\index{set-underscoregrammar@\verb`set_grammar`}
\begin{ocamldocdescription}
{\tt{set\_grammar gr grdef}} set the definiton of grammar {\tt{gr}} (previously
    declared with {\tt{declare\_grammar}}) to be  {\tt{grdef}}.  {\tt{Invalid\_argument}}
    is raised if {\tt{set\_grammar}} is used on a grammar that was not created
    with {\tt{declare\_grammar}}. The behavious is undefined if a  grammar  is
    set twice with {\tt{set\_grammar}}.


\end{ocamldocdescription}




\subsection{Parsing functions}




\label{val:Earley.parse-underscorebuffer}\begin{ocamldoccode}
val parse_buffer : {\textquotesingle}a grammar -> blank -> Input.buffer -> {\textquotesingle}a
\end{ocamldoccode}
\index{parse-underscorebuffer@\verb`parse_buffer`}
\begin{ocamldocdescription}
{\tt{parse\_buffer gr bl buf}} parses the buffer {\tt{buf}} using  the  grammar
    {\tt{gr}} and the blank function {\tt{bl}}. The exception {\tt{Parse\_error}} may be
    raised in case of error.


\end{ocamldocdescription}




\label{val:Earley.parse-underscorestring}\begin{ocamldoccode}
val parse_string : ?filename:string -> {\textquotesingle}a grammar -> blank -> string -> {\textquotesingle}a
\end{ocamldoccode}
\index{parse-underscorestring@\verb`parse_string`}
\begin{ocamldocdescription}
{\tt{parse\_string {\char126}filename gr bl str}} parses the string {\tt{str}} using the
    grammar {\tt{gr}} and the blank function {\tt{bl}}. An optional {\tt{filename}} can
    be provided for reference  to  the  input  in  error  messages.  The
    exception {\tt{Parse\_error}} may be raised in case of error.


\end{ocamldocdescription}




\label{val:Earley.parse-underscorechannel}\begin{ocamldoccode}
val parse_channel :
  ?filename:string ->
  {\textquotesingle}a grammar -> blank -> Stdlib.in_channel -> {\textquotesingle}a
\end{ocamldoccode}
\index{parse-underscorechannel@\verb`parse_channel`}
\begin{ocamldocdescription}
{\tt{parse\_channel {\char126}filename gr bl ch}} parses the contenst of  the  input
    channel {\tt{ch}} using the grammar {\tt{gr}} and the blank  function  {\tt{bl}}.  A
    {\tt{filename}} can be provided for reference to the input in case  of  an
    error. {\tt{parse\_channel}} may raise the {\tt{Parse\_error}} exception.


\end{ocamldocdescription}




\label{val:Earley.parse-underscorefile}\begin{ocamldoccode}
val parse_file : {\textquotesingle}a grammar -> blank -> string -> {\textquotesingle}a
\end{ocamldoccode}
\index{parse-underscorefile@\verb`parse_file`}
\begin{ocamldocdescription}
{\tt{parse\_file gr bl fn}} parses the file {\tt{fn}} using the grammar {\tt{gr}} and
    the blank function {\tt{bl}}. The exception {\tt{Parse\_error}} may be raised in
    case of error.


\end{ocamldocdescription}




\label{val:Earley.partial-underscoreparse-underscorebuffer}\begin{ocamldoccode}
val partial_parse_buffer :
  {\textquotesingle}a grammar ->
  blank ->
  ?blank_after:bool -> Input.buffer -> int -> {\textquotesingle}a * Input.buffer * int
\end{ocamldoccode}
\index{partial-underscoreparse-underscorebuffer@\verb`partial_parse_buffer`}
\begin{ocamldocdescription}
{\tt{partial\_parse\_buffer gr bl buf pos}} parses  input  from  the  buffer
    {\tt{buf}} starting a position {\tt{pos}}, using the grammar {\tt{gr}} and the blank
    function {\tt{bl}}. A triple is returned containing the  new  buffer,  the
    position that was reached during parsing, and the semantic result  of
    the parsing. The optional argument {\tt{blank\_after}}, {\tt{true}} by default,
    indicates if the returned position if after the final blank or not.
    Note that this function should not be used in the  defi-
    nition of a grammar using the {\tt{black\_box}} function.


\end{ocamldocdescription}




A functor providing support for using and {\tt{Input}} preprocessor.



\subsection{Debuging and flags}




\label{val:Earley.debug-underscorelvl}\begin{ocamldoccode}
val debug_lvl : int Stdlib.ref
\end{ocamldoccode}
\index{debug-underscorelvl@\verb`debug_lvl`}
\begin{ocamldocdescription}
{\tt{debug\_lvl}} is a flag that can be set for {\tt{Earley}} to display  debug
    data on {\tt{stderr}}. The default value is {\tt{0}}, and bigger numbers acti-
    vate more and more debuging informations.


\end{ocamldocdescription}




\label{val:Earley.warn-underscoremerge}\begin{ocamldoccode}
val warn_merge : bool Stdlib.ref
\end{ocamldoccode}
\index{warn-underscoremerge@\verb`warn_merge`}
\begin{ocamldocdescription}
{\tt{warn\_merge}} is a flag that is used to choose whether  warnings  are
    displayed or not when an ambiguity is encountered while parsing. The
    default value is {\tt{true}}.


\end{ocamldocdescription}




{\tt{keep\_all\_names}} is false by default and allow for inlining  grammar
    with a name to optimise parsing.  When debugging,  it is possible to
    set it to true  (before all grammar constructions) for more accurate
    messages.



\subsection{Greedy combinator}




\label{val:Earley.greedy}\begin{ocamldoccode}
val greedy : {\textquotesingle}a grammar -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{greedy@\verb`greedy`}
\begin{ocamldocdescription}
{\tt{greedy g}} parses g in a greedy way: only the longest match is considered.
    Still ambigous if the longest match is not unique


\end{ocamldocdescription}




\subsection{Sequencing combinators}




\label{val:Earley.sequence}\begin{ocamldoccode}
val sequence : {\textquotesingle}a grammar ->
  {\textquotesingle}b grammar -> ({\textquotesingle}a -> {\textquotesingle}b -> {\textquotesingle}c) -> {\textquotesingle}c grammar
\end{ocamldoccode}
\index{sequence@\verb`sequence`}
\begin{ocamldocdescription}
{\tt{sequence g1 g2 f}} is a grammar that first parses using {\tt{g1}}, and then
    parses using {\tt{g2}}. The results of the sequence is then obtained by applying
    {\tt{f}} to the results of {\tt{g1}} and {\tt{g2}}.


\end{ocamldocdescription}




{\tt{sequence\_position g1 g2 f}} is a grammar that first parses using {\tt{g1}}, and
    then parses using {\tt{g2}}. The results of the sequence is then obtained by
    applying {\tt{f}} to the results of {\tt{g1}} and {\tt{g2}}, and to the positions (i.e.
    buffer and index) of the corresponding parsed input.


    Remark: {\tt{sequence g1 g2 f}} is equivalent to
    {\tt{sequence\_position g1 g2 (fun \_ \_ \_ \_ -> f)}}.



\label{val:Earley.fsequence}\begin{ocamldoccode}
val fsequence : {\textquotesingle}a grammar -> ({\textquotesingle}a -> {\textquotesingle}b) grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{fsequence@\verb`fsequence`}
\begin{ocamldocdescription}
{\tt{fsequence g1 g2}} is a grammar that first parses using {\tt{g1}}, and then
    parses using {\tt{g2}}. The results of the sequence is then obtained by applying
    the result of {\tt{g1}} to the result of {\tt{g2}}.


    Remark: {\tt{fsequence g1 g2}} is equivalent to
    {\tt{sequence g1 g2 (fun x f -> f x)}}.


\end{ocamldocdescription}




same as fsequence, but the result of {\tt{g2}} also receive the position of the
    result of {\tt{g1}}.



\label{val:Earley.fsequence-underscoreignore}\begin{ocamldoccode}
val fsequence_ignore : {\textquotesingle}a grammar -> {\textquotesingle}b grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{fsequence-underscoreignore@\verb`fsequence_ignore`}
\begin{ocamldocdescription}
same as fsequence, but the result of {\tt{g2}} receives nothing, meaning
    we forget the result of {\tt{g1}}.


\end{ocamldocdescription}




\label{val:Earley.sequence3}\begin{ocamldoccode}
val sequence3 :
  {\textquotesingle}a grammar ->
  {\textquotesingle}b grammar ->
  {\textquotesingle}c grammar -> ({\textquotesingle}a -> {\textquotesingle}b -> {\textquotesingle}c -> {\textquotesingle}d) -> {\textquotesingle}d grammar
\end{ocamldoccode}
\index{sequence3@\verb`sequence3`}
\begin{ocamldocdescription}
{\tt{sequence3}} is similar to {\tt{sequence}}, but it composes three grammars into
    a sequence.


    Remark: {\tt{sequence3 g1 g2 g3 f}} is equivalent to
    {\tt{sequence (sequence g1 g2 f) g3 (fun f x -> f x)}}.


\end{ocamldocdescription}




\label{val:Earley.simple-underscoredependent-underscoresequence}\begin{ocamldoccode}
val simple_dependent_sequence :
  {\textquotesingle}a grammar -> ({\textquotesingle}a -> {\textquotesingle}b grammar) -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{simple-underscoredependent-underscoresequence@\verb`simple_dependent_sequence`}
\begin{ocamldocdescription}
{\tt{simple\_dependent\_sequence g1 g2}} is a grammar that first parses using {\tt{g1}},
    which returns a value {\tt{a}}, and then continues to parse with {\tt{g2 a}} and
    return its result.


\end{ocamldocdescription}




{\tt{dependent\_sequence g1 g2}} is a grammar that first parses using {\tt{g1}},
    which returns a value {\tt{(a,b)}}, and then continues to parse with {\tt{g2 a}} and
    return its result applied to {\tt{b}}. compared to the above function, allow
    memoizing the second grammar



$=$ fun g $\rightarrow$ dependent\_sequence g (fun x $\rightarrow$ x)



{\tt{option v g}} tries to parse the input as {\tt{g}}, and returns {\tt{v}} in case of
    failure.



\label{val:Earley.fixpoint}\begin{ocamldoccode}
val fixpoint : {\textquotesingle}a -> ({\textquotesingle}a -> {\textquotesingle}a) grammar -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{fixpoint@\verb`fixpoint`}
\begin{ocamldocdescription}
{\tt{fixpoint v g}} parses a repetition of one or more times the input parsed
    by {\tt{g}}. The value {\tt{v}} is used as the initial value (i.e. to finish the
    sequence).


    if parsing X with g returns a function gX, parsing X Y Z with fixpoint a g
    will return gX (gY (gZ a)).


    This consumes stack proportinal to the input length ! use revfixpoint $\ldots$


\end{ocamldocdescription}




as {\tt{fixpoint}} but parses at leat once with the given grammar



{\tt{listN g sep}} parses sequences of {\tt{g}} separated by  {\tt{sep}} of length at
    least {\tt{N}}, for {\tt{N=0,1}} or {\tt{2}}.



\label{val:Earley.alternatives}\begin{ocamldoccode}
val alternatives : {\textquotesingle}a grammar list -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{alternatives@\verb`alternatives`}
\begin{ocamldocdescription}
{\tt{alternatives [g1;...;gn]}} tries to parse using all the grammars
    {\tt{[g1;...;gn]}} and keeps only the first success.


\end{ocamldocdescription}




\label{val:Earley.apply}\begin{ocamldoccode}
val apply : ({\textquotesingle}a -> {\textquotesingle}b) -> {\textquotesingle}a grammar -> {\textquotesingle}b grammar
\end{ocamldoccode}
\index{apply@\verb`apply`}
\begin{ocamldocdescription}
{\tt{apply f g}} applies function {\tt{f}} to the value returned by the grammar
    {\tt{g}}.


\end{ocamldocdescription}




{\tt{apply\_position f g}} applies function {\tt{f}} to the value returned by the
    grammar {\tt{g}} and the positions at the beginning and at the end of the
    input parsed input.



{\tt{position g}} tranforms the grammar {\tt{g}} to add information about the
    position of the parsed text.



{\tt{test c f}} perform a test {\tt{f}} on the input buffer. Do not parse
    anything (position are unchanged). The charset {\tt{c}} should contains
    all character accepted as at the position given to f



{\tt{blank\_test c f}} same as above except that {\tt{f}} is applied to
    {\tt{buf{\textquotesingle} pos{\textquotesingle} buf pos}} where {\tt{(buf{\textquotesingle}, pos{\textquotesingle})}} is the position before the
    blank. The charset c should contains all character accepted as at
    the position (buf,pos). This allow to test the presence of blank
    or even to read the blank and return some information



a test that fails if there is no blank



a test that fails if there are some blank



\label{val:Earley.grammar-underscorefamily}\begin{ocamldoccode}
val grammar_family :
  ?param_to_string:({\textquotesingle}a -> string) ->
  string -> ({\textquotesingle}a -> {\textquotesingle}b grammar) * (({\textquotesingle}a -> {\textquotesingle}b grammar) -> unit)
\end{ocamldoccode}
\index{grammar-underscorefamily@\verb`grammar_family`}
\begin{ocamldocdescription}
{\tt{grammar\_family to\_str name}} returns a pair {\tt{(gs, set\_gs)}}, where {\tt{gs}}
    is a finite family of grammars parametrized by a value of type {\tt{{\textquotesingle}a}}. A name
    {\tt{name}} is to be provided for the family, and an optional function {\tt{to\_str}}
    can be provided to print the parameter and display better error messages.


\end{ocamldocdescription}




\begin{ocamldoccode}

   (* Declare the grammar family *)
   let (gr, set_gr) = grammar_family to_str name in

   ... code using grammars of gr to define mutually recursive grammars ...
   ... the grammars in gr cannot be used in "left position" ...
   ... (same restriction as for declare_grammar ...

   (* Define the grammar family *)
   let _ = set_gr the_grammars

   ... now the new family can be used ...
   
\end{ocamldoccode}




\label{val:Earley.grammar-underscoreprio}\begin{ocamldoccode}
val grammar_prio :
  ?param_to_string:({\textquotesingle}b -> string) ->
  string ->
  ({\textquotesingle}b -> {\textquotesingle}c grammar) *
  ((({\textquotesingle}b -> bool) * {\textquotesingle}c grammar) list * ({\textquotesingle}b -> {\textquotesingle}c grammar list) ->
   unit)
\end{ocamldoccode}
\index{grammar-underscoreprio@\verb`grammar_prio`}
\begin{ocamldocdescription}
Similar to the previous one, with an optimization.
    {\tt{grammar\_prio to\_str name}} returns a pair {\tt{(gs, set\_gs)}}, where
    {\tt{gs}} is a finite family of grammars parametrized by a value of type {\tt{{\textquotesingle}a}}.
    {\tt{set\_gs}} requires two lists of grammars to set the value of the grammar:\begin{itemize}
\item the first list are grammar that can only be activated by the parameter
      (if the given function return true)
\item the second list is used as for grammar family
\end{itemize}



\end{ocamldocdescription}




\label{val:Earley.grammar-underscoreprio-underscorefamily}\begin{ocamldoccode}
val grammar_prio_family :
  ?param_to_string:({\textquotesingle}a * {\textquotesingle}b -> string) ->
  string ->
  ({\textquotesingle}a -> {\textquotesingle}b -> {\textquotesingle}c grammar) *
  (({\textquotesingle}a ->
    (({\textquotesingle}b -> bool) * {\textquotesingle}c grammar) list * ({\textquotesingle}b -> {\textquotesingle}c grammar list)) ->
   unit)
\end{ocamldoccode}
\index{grammar-underscoreprio-underscorefamily@\verb`grammar_prio_family`}
\begin{ocamldocdescription}
A mixture of the two above


\end{ocamldocdescription}




\label{val:Earley.accept-underscoreempty}\begin{ocamldoccode}
val accept_empty : {\textquotesingle}a grammar -> bool
\end{ocamldoccode}
\index{accept-underscoreempty@\verb`accept_empty`}
\begin{ocamldocdescription}
{\tt{accept\_empty g}} returns {\tt{true}} if the grammar {\tt{g}} accepts the empty input
    and {\tt{false}} otherwise.


\end{ocamldocdescription}




\label{val:Earley.grammar-underscoreinfo}\begin{ocamldoccode}
val grammar_info : {\textquotesingle}a grammar -> bool * Charset.t
\end{ocamldoccode}
\index{grammar-underscoreinfo@\verb`grammar_info`}




\label{val:Earley.give-underscorename}\begin{ocamldoccode}
val give_name : string -> {\textquotesingle}a grammar -> {\textquotesingle}a grammar
\end{ocamldoccode}
\index{give-underscorename@\verb`give_name`}
\begin{ocamldocdescription}
give a name to the grammar. Usefull for debugging.


\end{ocamldocdescription}


\end{document}
