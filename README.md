PaComb: an efficient parsing library for OCaml
==============================================

## Overview

PaComb implements a representation of grammars with semantic actions (values
returned as a result of parsing). Parsing is performed by compiling grammars
defined with the `Grammar` module (or indirectly though a PPX extension) to
the combinators of the `Combinator` module. The library offers _scanner less_
parsing, but the `Lex` module provide a notion of _terminals_ and _blanks_
that give a simple way to write grammars in two phases, as usual.

The main advantage of PaComb and similar solutions, contrary to ocamlyacc, is
that grammars (compiled or not) are __first class values__. This allows using
the full power of OCaml for manipulating grammars. For example, this is very
useful when working with syntax extension mechanisms.

Importantly, the __performances__ of PaComb are very good: it is only two to
five times slower than grammars generated by ocamlyacc, which is a compiler.

## PPX syntax extension

Defining languages using the `Grammar` module directly is cumbersome. For that
reason, PaComb provides a BNF-like PPX syntax extension (enabled using the
`-ppx pacombPpx` compilation flag). An example with arithmetic expressions is
given below.
```ocaml
[%%parser
   type p = Atom | Prod | Sum
   let rec expr p =
     Atom < Prod < Sum
     ; (p=Atom) (x::FLOAT)                        => x
     ; (p=Atom) '(' (e::expr Sum) ')'             => e
     ; (p=Prod) (x::expr Prod) '*' (y::expr Atom) => x *. y
     ; (p=Prod) (x::expr Prod) '/' (y::expr Atom) => x /. y
     ; (p=Sum ) (x::expr Sum ) '+' (y::expr Prod) => x +. y
     ; (p=Sum ) (x::expr Sum ) '-' (y::expr Prod) => x -. y
]
```

The extension `[%%parser ...]` modifies the behaviour of let-bindings, which
are used for defining grammars. This applies both for `let` and `let rec`, the
latter being used for recursive grammars. An extension `[%grammar]` is also
provided at the level of expressions. We give below the BNF grammar for the
extension, together with a sketch of its semantics.
```
grammar ::= rule                                                   itself
       | grammar ; rule                                       Grammar.alt
rule ::= qitems => expr                            A rule with its action
       | expr < ... < expr                       priority order see below
qitems ::= ()                                               Grammar.empty
       | non_empty_qitems                                          itself
non_empty_qitems ::= qitem                                         itself
       | non_empty_qitems qitems                              Grammar.seq
qitem ::= item | (lid :: item)          give a name if used in the action
item ::= '...'                                  Grammar.term(Lex.char ())
       | "..."                                Grammar.term(Lex.string ())
       | INT                                     Grammar.term(Lex.int ())
       | FLOAT                                 Grammar.term(Lex.float ())
       | RE(expr)      Grammar.term(Lex.regexp (Regexp.from_string expr))
       | expr                                                      itself
```

- non recursive let bindings correspond to just a name for the grammar.
- recursive let bindings correspond either to
  - [Grammar.declare_grammar + Grammar.set_grammar] (if no paramater)
  - [Grammar.grammar_familly + setting the grammar] if a parameter is given.
  In the latter case, a rule `p_1 < p_2 < ... < p_n` will automatically add
  rules to include the grammar parametrized by `p_i` in the grammar
  parametrized by `p_(i+1)`.

Anything which does not corespond to this grammar will we keeped unchanged
in the structure as ocaml code (like the type definition in the example
above).  A mutually recursive definition can also mix the definition of
grammars (parametric of not) with the definition of normal ocaml values.

## Limitations

Pacomb must eliminate left recursion in grammars in order to use combinators
that would loop otherwise. However, left recursion is not supported if it
traverses:

- A `Grammar.layout` contructor to change blanks (probably possible to solve this,
  but probably not woth it).

- A `Grammar.desq` constructor that provides dependent sequence. Solving this
  is an open problem.

- Grammars are not left factorised automatically: (A B) | (A C) may parse A twice.
  two solutions
  - left factorise your grammar yourself,
  - Use Grammar.cache trading memory for speed.

- The ppx extension is not too bad but still suffer from the fact that is
  uses a sublanguage of OCaml to describe grammar. For instance
  `[%grammar (_::INT) => 0]` is not legal because `_` cannot be used in an Ocaml
  expression.
