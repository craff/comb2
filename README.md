PaComb: an efficient parsing library for OCaml
==============================================

## Overview

PaComb implements a representation of grammars with semantic actions (values
returned as a result of parsing). Parsing is performed by compiling grammars
defined with the `Grammar` module (or indirectly though a PPX extension) to
the combinators of the `Combinator` module. The library offers _scanner less_
parsing, but the `Lex` module provide a notion of _terminals_ and _blanks_
that give a simple way to write grammars in two phases, as usual.

The main advantage of PaComb and similar solutions, contrary to ocamlyacc, is
that grammars (compiled or not) are __first class values__. This allows using
the full power of OCaml for manipulating grammars. For example, this is very
useful when working with syntax extension mechanisms.

Importantly, the __performances__ of PaComb are very good: it is only two to
five times slower than grammars generated by ocamlyacc, which is a compiler.

## PPX syntax extension

Defining languages using the `Grammar` module directly is cumbersome. For that
reason, PaComb provides a BNF-like PPX syntax extension (enabled using the
`-ppx pacombPpx` compilation flag). An example with arithmetic expressions is
given below.
```ocaml
[%%parser
   type p = Atom | Prod | Sum
   let rec expr p =
     Atom < Prod < Sum
     ; (p=Atom) (x::FLOAT)                        => x
     ; (p=Atom) '(' (e::expr Sum) ')'             => e
     ; (p=Prod) (x::expr Prod) '*' (y::expr Atom) => x *. y
     ; (p=Prod) (x::expr Prod) '/' (y::expr Atom) => x /. y
     ; (p=Sum ) (x::expr Sum ) '+' (y::expr Prod) => x +. y
     ; (p=Sum ) (x::expr Sum ) '-' (y::expr Prod) => x -. y
]
```

The extension `[%%parser ...]` extend expression with grammars of type `'a
Grammar.t` and modifies the behaviour of let-bindings especially recursive
ones to use `declare_grammar`, `set_grammar` and `grammar_family`. recursive
grammars. Recall that due to the limitation of ppx, we use a sub syntax of
OCaml expression for grammars. It is therefore not a good idea to use "=>" as
an infix inside `[%parse ...]`.


We give below the BNF grammar for the extension, together with a sketch of
its semantics.
```
grammar ::= rule                                                   itself
       | grammar ; rule                                       Grammar.alt
rule ::= qitems => expr                            A rule with its action
       | expr < ... < expr                       priority order see below
qitems ::= ()                                               Grammar.empty
       | non_empty_qitems                                          itself
non_empty_qitems ::= qitem                                         itself
       | non_empty_qitems qitems                              Grammar.seq
qitem ::= item | (pat :: item)          give a name if used in the action
item ::= '...'                                  Grammar.term(Lex.char ())
       | "..."                                Grammar.term(Lex.string ())
       | INT                                     Grammar.term(Lex.int ())
       | FLOAT                                 Grammar.term(Lex.float ())
       | RE(expr)      Grammar.term(Lex.regexp (Regexp.from_string expr))
       | expr                                                      itself
pat ::= lid
       | (pat : coretype)
       | pat = lid                               encoding of [pat as lid]
       | (pat, ..., pat)
       | M.pat
```
pat correspond to an encoding of patterns in expressions. Beware that "_" is
invalid, use "__" instead.

In action code (expression right of "=>"), a lid_lpos or lid_rpos will denote
respectively the left and right position of the time named lid.  If the item
is matched by a tuple, you must use `pat = lid` syntax to give a name to the
whole item.

The grammar above allows for some nesting as in:

```
[%%parser
 type p = Atom | Prod | Sum
 let rec
     expr p = Atom < Prod < Sum
            ; (p=Atom) (x::FLOAT)                        => x
            ; (p=Atom) '(' (e::expr Sum) ')'             => e
            ; (p=Prod) (x::expr Prod) => ( '*' (y::expr Atom) => x*.y
                                         ; '/' (y::expr Atom) => x/.y)
            ; (p=Sum ) (x::expr Sum ) => ('+' (y::expr Prod) => x+.y
                                         ; '-' (y::expr Prod) => x-.y)
```]

But when using this, beware that `x` is not available before the final action
code, it can not be used for selecting  grammar rule. `(p::prio) => (x::g p) => x`
will report `p` as unbounded.

- non recursive let bindings correspond to just a name for the grammar.
- recursive let bindings correspond either to
  - `Grammar.declare_grammar + Grammar.set_grammar` (if no paramater)
  - `Grammar.grammar_familly + setting the grammar` if a parameter is given.

In both cases, a rule `p_1 < p_2 < ... < p_n` will automatically add rules to
include the grammar parametrized by `p_i` in the grammar parametrized by
`p_(i+1)`.

Anything which does not correspond to this grammar will we keeped unchanged
in the structure as ocaml code (like the type definition in the example
above).  A mutually recursive definition can also mix the definition of
grammars (parametric of not) with the definition of normal ocaml values.

## Limitations

Pacomb must eliminate left recursion in grammars in order to use combinators
that would loop otherwise. However, left recursion is not supported if it
traverses:

- A `Grammar.layout` contructor to change blanks (probably possible to solve this,
  but probably not woth it).

- A `Grammar.desq` constructor that provides dependent sequence. Solving this
  is an open problem.

- Grammars are not left factorised automatically: (A B) | (A C) may parse A twice.
  two solutions
  - left factorise your grammar yourself,
  - Use Grammar.cache trading memory for speed.

- The ppx extension is not too bad but still suffer from the fact that is
  uses a sublanguage of OCaml to describe grammar. For instance
  `[%parser let g = (_::INT) => 0]` is not legal because `_` cannot be used in
  an Ocaml expression.
